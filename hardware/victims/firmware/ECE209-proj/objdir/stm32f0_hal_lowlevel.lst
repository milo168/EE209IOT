   1              		.syntax unified
   2              		.cpu cortex-m0
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"stm32f0_hal_lowlevel.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.HAL_GetTick,"ax",%progbits
  20              		.align	2
  21              		.global	HAL_GetTick
  22              		.code	16
  23              		.thumb_func
  25              	HAL_GetTick:
  26              	.LFB35:
  27              		.file 1 ".././hal/stm32f0/stm32f0_hal_lowlevel.c"
   1:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /* This file combines several STM32F4 HAL Functions into one file. This was done
   2:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    for space reasons, to avoid having several MB of HAL functions that most people
   3:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    will not use. In addition this HAL is slightly less demanding (no interrupts),
   4:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    but less robust as doesn't implement the timeouts.
   5:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    
   6:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    The original HAL files are COPYRIGHT STMicroelectronics, as shown below:
   7:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** */
   8:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
   9:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /*
  10:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * COPYRIGHT(c) 2017 STMicroelectronics
  11:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
  12:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * Redistribution and use in source and binary forms, with or without modification,
  13:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * are permitted provided that the following conditions are met:
  14:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  15:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      this list of conditions and the following disclaimer.
  16:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  17:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      this list of conditions and the following disclaimer in the documentation
  18:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      and/or other materials provided with the distribution.
  19:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  20:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      may be used to endorse or promote products derived from this software
  21:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      without specific prior written permission.
  22:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
  23:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  24:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  25:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  27:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  28:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  29:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  30:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  31:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  32:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
  34:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   ******************************************************************************
  35:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** */ 
  36:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  37:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  38:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0_hal.h"
  39:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0_hal_lowlevel.h"
  40:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_rcc.h"
  41:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_gpio.h"
  42:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_dma.h"
  43:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_uart.h"
  44:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_flash.h"
  45:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  46:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define assert_param(expr) ((void)0U)
  47:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  48:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_GetTick(void)
  49:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
  28              		.loc 1 49 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 00AF     		add	r7, sp, #0
  38              	.LCFI1:
  39              		.cfi_def_cfa_register 7
  50:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	static uint32_t tick;
  51:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	return tick++;;
  40              		.loc 1 51 0
  41 0004 044B     		ldr	r3, .L3
  42 0006 1A68     		ldr	r2, [r3]
  43 0008 511C     		adds	r1, r2, #1
  44 000a 034B     		ldr	r3, .L3
  45 000c 1960     		str	r1, [r3]
  46 000e 1300     		movs	r3, r2
  52:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
  47              		.loc 1 52 0
  48 0010 1800     		movs	r0, r3
  49 0012 BD46     		mov	sp, r7
  50              		@ sp needed
  51 0014 80BD     		pop	{r7, pc}
  52              	.L4:
  53 0016 C046     		.align	2
  54              	.L3:
  55 0018 00000000 		.word	tick.6057
  56              		.cfi_endproc
  57              	.LFE35:
  59              		.global	SystemCoreClock
  60              		.data
  61              		.align	2
  64              	SystemCoreClock:
  65 0000 00127A00 		.word	8000000
  66              		.section	.text.HAL_RCC_GetSysClockFreq,"ax",%progbits
  67              		.align	2
  68              		.global	HAL_RCC_GetSysClockFreq
  69              		.code	16
  70              		.thumb_func
  72              	HAL_RCC_GetSysClockFreq:
  73              	.LFB36:
  53:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  54:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define UART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | \
  55:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                      USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8)) /*!< UART or U
  56:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 									 
  57:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t SystemCoreClock = 8000000;
  58:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  59:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  60:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_RCC_GetSysClockFreq(void)
  61:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
  74              		.loc 1 61 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 1, uses_anonymous_args = 0
  78 0000 80B5     		push	{r7, lr}
  79              	.LCFI2:
  80              		.cfi_def_cfa_offset 8
  81              		.cfi_offset 7, -8
  82              		.cfi_offset 14, -4
  83 0002 00AF     		add	r7, sp, #0
  84              	.LCFI3:
  85              		.cfi_def_cfa_register 7
  62:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	return 7372800U;
  86              		.loc 1 62 0
  87 0004 E123     		movs	r3, #225
  88 0006 DB03     		lsls	r3, r3, #15
  63:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
  89              		.loc 1 63 0
  90 0008 1800     		movs	r0, r3
  91 000a BD46     		mov	sp, r7
  92              		@ sp needed
  93 000c 80BD     		pop	{r7, pc}
  94              		.cfi_endproc
  95              	.LFE36:
  97 000e C046     		.section	.text.HAL_RCC_GetPCLK1Freq,"ax",%progbits
  98              		.align	2
  99              		.global	HAL_RCC_GetPCLK1Freq
 100              		.code	16
 101              		.thumb_func
 103              	HAL_RCC_GetPCLK1Freq:
 104              	.LFB37:
  64:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  65:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_RCC_GetPCLK1Freq(void)
  66:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 105              		.loc 1 66 0
 106              		.cfi_startproc
 107              		@ args = 0, pretend = 0, frame = 0
 108              		@ frame_needed = 1, uses_anonymous_args = 0
 109 0000 80B5     		push	{r7, lr}
 110              	.LCFI4:
 111              		.cfi_def_cfa_offset 8
 112              		.cfi_offset 7, -8
 113              		.cfi_offset 14, -4
 114 0002 00AF     		add	r7, sp, #0
 115              	.LCFI5:
 116              		.cfi_def_cfa_register 7
  67:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	return 7372800U;
 117              		.loc 1 67 0
 118 0004 E123     		movs	r3, #225
 119 0006 DB03     		lsls	r3, r3, #15
  68:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 120              		.loc 1 68 0
 121 0008 1800     		movs	r0, r3
 122 000a BD46     		mov	sp, r7
 123              		@ sp needed
 124 000c 80BD     		pop	{r7, pc}
 125              		.cfi_endproc
 126              	.LFE37:
 128 000e C046     		.section	.text.HAL_RCC_GetPCLK2Freq,"ax",%progbits
 129              		.align	2
 130              		.global	HAL_RCC_GetPCLK2Freq
 131              		.code	16
 132              		.thumb_func
 134              	HAL_RCC_GetPCLK2Freq:
 135              	.LFB38:
  69:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  70:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
  71:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Returns the PCLK2 frequency
  72:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   Each time PCLK2 changes, this function must be called to update the
  73:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrec
  74:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval PCLK2 frequency
  75:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
  76:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_RCC_GetPCLK2Freq(void)
  77:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 136              		.loc 1 77 0
 137              		.cfi_startproc
 138              		@ args = 0, pretend = 0, frame = 0
 139              		@ frame_needed = 1, uses_anonymous_args = 0
 140 0000 80B5     		push	{r7, lr}
 141              	.LCFI6:
 142              		.cfi_def_cfa_offset 8
 143              		.cfi_offset 7, -8
 144              		.cfi_offset 14, -4
 145 0002 00AF     		add	r7, sp, #0
 146              	.LCFI7:
 147              		.cfi_def_cfa_register 7
  78:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  79:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   //return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_C
  80:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return 7372800;
 148              		.loc 1 80 0
 149 0004 E123     		movs	r3, #225
 150 0006 DB03     		lsls	r3, r3, #15
  81:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 151              		.loc 1 81 0
 152 0008 1800     		movs	r0, r3
 153 000a BD46     		mov	sp, r7
 154              		@ sp needed
 155 000c 80BD     		pop	{r7, pc}
 156              		.cfi_endproc
 157              	.LFE38:
 159 000e C046     		.section	.text.HAL_RCC_OscConfig,"ax",%progbits
 160              		.align	2
 161              		.global	HAL_RCC_OscConfig
 162              		.code	16
 163              		.thumb_func
 165              	HAL_RCC_OscConfig:
 166              	.LFB39:
  82:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  83:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
  84:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Initializes the RCC Oscillators according to the specified parameters in the
  85:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         RCC_OscInitTypeDef.
  86:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
  87:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         contains the configuration information for the RCC Oscillators.
  88:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   The PLL is not disabled when used as system clock.
  89:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
  90:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         supported by this macro. User should request a transition to LSE Off
  91:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         first and then LSE On or LSE Bypass.
  92:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
  93:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         supported by this macro. User should request a transition to HSE Off
  94:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         first and then HSE On or HSE Bypass.
  95:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
  96:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
  97:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
  98:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 167              		.loc 1 98 0
 168              		.cfi_startproc
 169              		@ args = 0, pretend = 0, frame = 24
 170              		@ frame_needed = 1, uses_anonymous_args = 0
 171 0000 80B5     		push	{r7, lr}
 172              	.LCFI8:
 173              		.cfi_def_cfa_offset 8
 174              		.cfi_offset 7, -8
 175              		.cfi_offset 14, -4
 176 0002 86B0     		sub	sp, sp, #24
 177              	.LCFI9:
 178              		.cfi_def_cfa_offset 32
 179 0004 00AF     		add	r7, sp, #0
 180              	.LCFI10:
 181              		.cfi_def_cfa_register 7
 182 0006 7860     		str	r0, [r7, #4]
  99:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    uint32_t tickstart = 0U;
 183              		.loc 1 99 0
 184 0008 0023     		movs	r3, #0
 185 000a 3B61     		str	r3, [r7, #16]
 100:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 101:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 102:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(RCC_OscInitStruct != NULL);
 103:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 104:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 105:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------- HSE Configuration ------------------------*/ 
 106:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 186              		.loc 1 106 0
 187 000c 7B68     		ldr	r3, [r7, #4]
 188 000e 1B68     		ldr	r3, [r3]
 189 0010 0122     		movs	r2, #1
 190 0012 1340     		ands	r3, r2
 191 0014 00D1     		bne	.LCB129
 192 0016 8AE0     		b	.L12	@long jump
 193              	.LCB129:
 107:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 108:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 109:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 110:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 111:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowe
 112:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 194              		.loc 1 112 0
 195 0018 C24B     		ldr	r3, .L73
 196 001a 5B68     		ldr	r3, [r3, #4]
 197 001c 0C22     		movs	r2, #12
 198 001e 1340     		ands	r3, r2
 199 0020 042B     		cmp	r3, #4
 200 0022 0BD0     		beq	.L13
 113:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_
 201              		.loc 1 113 0
 202 0024 BF4B     		ldr	r3, .L73
 203 0026 5B68     		ldr	r3, [r3, #4]
 204 0028 0C22     		movs	r2, #12
 205 002a 1340     		ands	r3, r2
 206 002c 082B     		cmp	r3, #8
 207 002e 13D1     		bne	.L14
 208              		.loc 1 113 0 is_stmt 0 discriminator 1
 209 0030 BC4B     		ldr	r3, .L73
 210 0032 5A68     		ldr	r2, [r3, #4]
 211 0034 8023     		movs	r3, #128
 212 0036 5B02     		lsls	r3, r3, #9
 213 0038 1340     		ands	r3, r2
 214 003a 0DD0     		beq	.L14
 215              	.L13:
 114:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 115:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_
 216              		.loc 1 115 0 is_stmt 1
 217 003c B94B     		ldr	r3, .L73
 218 003e 1A68     		ldr	r2, [r3]
 219 0040 8023     		movs	r3, #128
 220 0042 9B02     		lsls	r3, r3, #10
 221 0044 1340     		ands	r3, r2
 222 0046 00D1     		bne	.LCB156
 223 0048 70E0     		b	.L72	@long jump
 224              	.LCB156:
 225              		.loc 1 115 0 is_stmt 0 discriminator 1
 226 004a 7B68     		ldr	r3, [r7, #4]
 227 004c 5B68     		ldr	r3, [r3, #4]
 228 004e 002B     		cmp	r3, #0
 229 0050 00D0     		beq	.LCB160
 230 0052 6BE0     		b	.L72	@long jump
 231              	.LCB160:
 116:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 117:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 232              		.loc 1 117 0 is_stmt 1
 233 0054 0123     		movs	r3, #1
 234 0056 B6E2     		b	.L16
 235              	.L14:
 118:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 119:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 120:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 121:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 122:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Set the new HSE configuration ---------------------------------------*/
 123:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 236              		.loc 1 123 0
 237 0058 7B68     		ldr	r3, [r7, #4]
 238 005a 5B68     		ldr	r3, [r3, #4]
 239 005c 012B     		cmp	r3, #1
 240 005e 07D1     		bne	.L17
 241              		.loc 1 123 0 is_stmt 0 discriminator 1
 242 0060 B04B     		ldr	r3, .L73
 243 0062 B04A     		ldr	r2, .L73
 244 0064 1268     		ldr	r2, [r2]
 245 0066 8021     		movs	r1, #128
 246 0068 4902     		lsls	r1, r1, #9
 247 006a 0A43     		orrs	r2, r1
 248 006c 1A60     		str	r2, [r3]
 249 006e 2FE0     		b	.L18
 250              	.L17:
 251              		.loc 1 123 0 discriminator 2
 252 0070 7B68     		ldr	r3, [r7, #4]
 253 0072 5B68     		ldr	r3, [r3, #4]
 254 0074 002B     		cmp	r3, #0
 255 0076 0CD1     		bne	.L19
 256              		.loc 1 123 0 discriminator 3
 257 0078 AA4B     		ldr	r3, .L73
 258 007a AA4A     		ldr	r2, .L73
 259 007c 1268     		ldr	r2, [r2]
 260 007e AA49     		ldr	r1, .L73+4
 261 0080 0A40     		ands	r2, r1
 262 0082 1A60     		str	r2, [r3]
 263 0084 A74B     		ldr	r3, .L73
 264 0086 A74A     		ldr	r2, .L73
 265 0088 1268     		ldr	r2, [r2]
 266 008a A849     		ldr	r1, .L73+8
 267 008c 0A40     		ands	r2, r1
 268 008e 1A60     		str	r2, [r3]
 269 0090 1EE0     		b	.L18
 270              	.L19:
 271              		.loc 1 123 0 discriminator 4
 272 0092 7B68     		ldr	r3, [r7, #4]
 273 0094 5B68     		ldr	r3, [r3, #4]
 274 0096 052B     		cmp	r3, #5
 275 0098 0ED1     		bne	.L20
 276              		.loc 1 123 0 discriminator 5
 277 009a A24B     		ldr	r3, .L73
 278 009c A14A     		ldr	r2, .L73
 279 009e 1268     		ldr	r2, [r2]
 280 00a0 8021     		movs	r1, #128
 281 00a2 C902     		lsls	r1, r1, #11
 282 00a4 0A43     		orrs	r2, r1
 283 00a6 1A60     		str	r2, [r3]
 284 00a8 9E4B     		ldr	r3, .L73
 285 00aa 9E4A     		ldr	r2, .L73
 286 00ac 1268     		ldr	r2, [r2]
 287 00ae 8021     		movs	r1, #128
 288 00b0 4902     		lsls	r1, r1, #9
 289 00b2 0A43     		orrs	r2, r1
 290 00b4 1A60     		str	r2, [r3]
 291 00b6 0BE0     		b	.L18
 292              	.L20:
 293              		.loc 1 123 0 discriminator 6
 294 00b8 9A4B     		ldr	r3, .L73
 295 00ba 9A4A     		ldr	r2, .L73
 296 00bc 1268     		ldr	r2, [r2]
 297 00be 9A49     		ldr	r1, .L73+4
 298 00c0 0A40     		ands	r2, r1
 299 00c2 1A60     		str	r2, [r3]
 300 00c4 974B     		ldr	r3, .L73
 301 00c6 974A     		ldr	r2, .L73
 302 00c8 1268     		ldr	r2, [r2]
 303 00ca 9849     		ldr	r1, .L73+8
 304 00cc 0A40     		ands	r2, r1
 305 00ce 1A60     		str	r2, [r3]
 306              	.L18:
 124:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 125:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 126:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* Check the HSE State */
 127:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 307              		.loc 1 127 0 is_stmt 1
 308 00d0 7B68     		ldr	r3, [r7, #4]
 309 00d2 5B68     		ldr	r3, [r3, #4]
 310 00d4 002B     		cmp	r3, #0
 311 00d6 14D0     		beq	.L21
 128:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 129:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 130:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 312              		.loc 1 130 0
 313 00d8 FFF7FEFF 		bl	HAL_GetTick
 314 00dc 0300     		movs	r3, r0
 315 00de 3B61     		str	r3, [r7, #16]
 131:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 132:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSE is ready */
 133:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 316              		.loc 1 133 0
 317 00e0 08E0     		b	.L22
 318              	.L23:
 134:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 135:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 319              		.loc 1 135 0
 320 00e2 FFF7FEFF 		bl	HAL_GetTick
 321 00e6 0200     		movs	r2, r0
 322 00e8 3B69     		ldr	r3, [r7, #16]
 323 00ea D31A     		subs	r3, r2, r3
 324 00ec 642B     		cmp	r3, #100
 325 00ee 01D9     		bls	.L22
 136:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 137:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 326              		.loc 1 137 0
 327 00f0 0323     		movs	r3, #3
 328 00f2 68E2     		b	.L16
 329              	.L22:
 133:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 330              		.loc 1 133 0
 331 00f4 8B4B     		ldr	r3, .L73
 332 00f6 1A68     		ldr	r2, [r3]
 333 00f8 8023     		movs	r3, #128
 334 00fa 9B02     		lsls	r3, r3, #10
 335 00fc 1340     		ands	r3, r2
 336 00fe F0D0     		beq	.L23
 337 0100 15E0     		b	.L12
 338              	.L21:
 138:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 139:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 140:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 141:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 142:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 143:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 144:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 339              		.loc 1 144 0
 340 0102 FFF7FEFF 		bl	HAL_GetTick
 341 0106 0300     		movs	r3, r0
 342 0108 3B61     		str	r3, [r7, #16]
 145:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 146:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSE is disabled */
 147:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 343              		.loc 1 147 0
 344 010a 08E0     		b	.L24
 345              	.L25:
 148:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 149:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****            if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 346              		.loc 1 149 0
 347 010c FFF7FEFF 		bl	HAL_GetTick
 348 0110 0200     		movs	r2, r0
 349 0112 3B69     		ldr	r3, [r7, #16]
 350 0114 D31A     		subs	r3, r2, r3
 351 0116 642B     		cmp	r3, #100
 352 0118 01D9     		bls	.L24
 150:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 151:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 353              		.loc 1 151 0
 354 011a 0323     		movs	r3, #3
 355 011c 53E2     		b	.L16
 356              	.L24:
 147:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 357              		.loc 1 147 0
 358 011e 814B     		ldr	r3, .L73
 359 0120 1A68     		ldr	r2, [r3]
 360 0122 8023     		movs	r3, #128
 361 0124 9B02     		lsls	r3, r3, #10
 362 0126 1340     		ands	r3, r2
 363 0128 F0D1     		bne	.L25
 364 012a 00E0     		b	.L12
 365              	.L72:
 115:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 366              		.loc 1 115 0
 367 012c C046     		nop
 368              	.L12:
 152:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 153:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 154:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 155:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 156:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 157:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- HSI Configuration --------------------------*/ 
 158:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 369              		.loc 1 158 0
 370 012e 7B68     		ldr	r3, [r7, #4]
 371 0130 1B68     		ldr	r3, [r3]
 372 0132 0222     		movs	r2, #2
 373 0134 1340     		ands	r3, r2
 374 0136 00D1     		bne	.LCB307
 375 0138 69E0     		b	.L26	@long jump
 376              	.LCB307:
 159:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 160:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 161:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 162:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 163:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 164:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock *
 165:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 377              		.loc 1 165 0
 378 013a 7A4B     		ldr	r3, .L73
 379 013c 5B68     		ldr	r3, [r3, #4]
 380 013e 0C22     		movs	r2, #12
 381 0140 1340     		ands	r3, r2
 382 0142 0BD0     		beq	.L27
 166:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_
 383              		.loc 1 166 0
 384 0144 774B     		ldr	r3, .L73
 385 0146 5B68     		ldr	r3, [r3, #4]
 386 0148 0C22     		movs	r2, #12
 387 014a 1340     		ands	r3, r2
 388 014c 082B     		cmp	r3, #8
 389 014e 1CD1     		bne	.L28
 390              		.loc 1 166 0 is_stmt 0 discriminator 1
 391 0150 744B     		ldr	r3, .L73
 392 0152 5A68     		ldr	r2, [r3, #4]
 393 0154 8023     		movs	r3, #128
 394 0156 5B02     		lsls	r3, r3, #9
 395 0158 1340     		ands	r3, r2
 396 015a 16D1     		bne	.L28
 397              	.L27:
 167:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 168:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* When HSI is used as system clock it will not disabled */
 169:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_
 398              		.loc 1 169 0 is_stmt 1
 399 015c 714B     		ldr	r3, .L73
 400 015e 1B68     		ldr	r3, [r3]
 401 0160 0222     		movs	r2, #2
 402 0162 1340     		ands	r3, r2
 403 0164 05D0     		beq	.L29
 404              		.loc 1 169 0 is_stmt 0 discriminator 1
 405 0166 7B68     		ldr	r3, [r7, #4]
 406 0168 DB68     		ldr	r3, [r3, #12]
 407 016a 012B     		cmp	r3, #1
 408 016c 01D0     		beq	.L29
 170:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 171:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 409              		.loc 1 171 0 is_stmt 1
 410 016e 0123     		movs	r3, #1
 411 0170 29E2     		b	.L16
 412              	.L29:
 172:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 173:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Otherwise, just the calibration is allowed */
 174:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 175:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 176:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
 177:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 413              		.loc 1 177 0
 414 0172 6C4A     		ldr	r2, .L73
 415 0174 6B4B     		ldr	r3, .L73
 416 0176 1B68     		ldr	r3, [r3]
 417 0178 F821     		movs	r1, #248
 418 017a 8B43     		bics	r3, r1
 419 017c 1900     		movs	r1, r3
 420 017e 7B68     		ldr	r3, [r7, #4]
 421 0180 1B69     		ldr	r3, [r3, #16]
 422 0182 DB00     		lsls	r3, r3, #3
 423 0184 0B43     		orrs	r3, r1
 424 0186 1360     		str	r3, [r2]
 169:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 425              		.loc 1 169 0
 426 0188 41E0     		b	.L26
 427              	.L28:
 178:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 179:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 180:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 181:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 182:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI State */
 183:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 428              		.loc 1 183 0
 429 018a 7B68     		ldr	r3, [r7, #4]
 430 018c DB68     		ldr	r3, [r3, #12]
 431 018e 002B     		cmp	r3, #0
 432 0190 24D0     		beq	.L30
 184:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 185:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* Enable the Internal High Speed oscillator (HSI). */
 186:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_ENABLE();
 433              		.loc 1 186 0
 434 0192 644B     		ldr	r3, .L73
 435 0194 634A     		ldr	r2, .L73
 436 0196 1268     		ldr	r2, [r2]
 437 0198 0121     		movs	r1, #1
 438 019a 0A43     		orrs	r2, r1
 439 019c 1A60     		str	r2, [r3]
 187:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 188:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 189:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 440              		.loc 1 189 0
 441 019e FFF7FEFF 		bl	HAL_GetTick
 442 01a2 0300     		movs	r3, r0
 443 01a4 3B61     		str	r3, [r7, #16]
 190:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 191:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI is ready */
 192:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 444              		.loc 1 192 0
 445 01a6 08E0     		b	.L31
 446              	.L32:
 193:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 194:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 447              		.loc 1 194 0
 448 01a8 FFF7FEFF 		bl	HAL_GetTick
 449 01ac 0200     		movs	r2, r0
 450 01ae 3B69     		ldr	r3, [r7, #16]
 451 01b0 D31A     		subs	r3, r2, r3
 452 01b2 022B     		cmp	r3, #2
 453 01b4 01D9     		bls	.L31
 195:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 196:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 454              		.loc 1 196 0
 455 01b6 0323     		movs	r3, #3
 456 01b8 05E2     		b	.L16
 457              	.L31:
 192:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 458              		.loc 1 192 0
 459 01ba 5A4B     		ldr	r3, .L73
 460 01bc 1B68     		ldr	r3, [r3]
 461 01be 0222     		movs	r2, #2
 462 01c0 1340     		ands	r3, r2
 463 01c2 F1D0     		beq	.L32
 197:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 198:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 199:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                 
 200:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
 201:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 464              		.loc 1 201 0
 465 01c4 574A     		ldr	r2, .L73
 466 01c6 574B     		ldr	r3, .L73
 467 01c8 1B68     		ldr	r3, [r3]
 468 01ca F821     		movs	r1, #248
 469 01cc 8B43     		bics	r3, r1
 470 01ce 1900     		movs	r1, r3
 471 01d0 7B68     		ldr	r3, [r7, #4]
 472 01d2 1B69     		ldr	r3, [r3, #16]
 473 01d4 DB00     		lsls	r3, r3, #3
 474 01d6 0B43     		orrs	r3, r1
 475 01d8 1360     		str	r3, [r2]
 476 01da 18E0     		b	.L26
 477              	.L30:
 202:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 203:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 204:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 205:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the Internal High Speed oscillator (HSI). */
 206:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_DISABLE();
 478              		.loc 1 206 0
 479 01dc 514B     		ldr	r3, .L73
 480 01de 514A     		ldr	r2, .L73
 481 01e0 1268     		ldr	r2, [r2]
 482 01e2 0121     		movs	r1, #1
 483 01e4 8A43     		bics	r2, r1
 484 01e6 1A60     		str	r2, [r3]
 207:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 208:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 209:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 485              		.loc 1 209 0
 486 01e8 FFF7FEFF 		bl	HAL_GetTick
 487 01ec 0300     		movs	r3, r0
 488 01ee 3B61     		str	r3, [r7, #16]
 210:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 211:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI is disabled */
 212:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 489              		.loc 1 212 0
 490 01f0 08E0     		b	.L33
 491              	.L34:
 213:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 214:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 492              		.loc 1 214 0
 493 01f2 FFF7FEFF 		bl	HAL_GetTick
 494 01f6 0200     		movs	r2, r0
 495 01f8 3B69     		ldr	r3, [r7, #16]
 496 01fa D31A     		subs	r3, r2, r3
 497 01fc 022B     		cmp	r3, #2
 498 01fe 01D9     		bls	.L33
 215:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 216:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 499              		.loc 1 216 0
 500 0200 0323     		movs	r3, #3
 501 0202 E0E1     		b	.L16
 502              	.L33:
 212:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 503              		.loc 1 212 0
 504 0204 474B     		ldr	r3, .L73
 505 0206 1B68     		ldr	r3, [r3]
 506 0208 0222     		movs	r2, #2
 507 020a 1340     		ands	r3, r2
 508 020c F1D1     		bne	.L34
 509              	.L26:
 217:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 218:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 219:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 220:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 221:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 222:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ LSI Configuration -------------------------*/ 
 223:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 510              		.loc 1 223 0
 511 020e 7B68     		ldr	r3, [r7, #4]
 512 0210 1B68     		ldr	r3, [r3]
 513 0212 0822     		movs	r2, #8
 514 0214 1340     		ands	r3, r2
 515 0216 36D0     		beq	.L35
 224:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 225:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 226:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 227:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 228:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the LSI State */
 229:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 516              		.loc 1 229 0
 517 0218 7B68     		ldr	r3, [r7, #4]
 518 021a DB69     		ldr	r3, [r3, #28]
 519 021c 002B     		cmp	r3, #0
 520 021e 19D0     		beq	.L36
 230:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 231:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable the Internal Low Speed oscillator (LSI). */
 232:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_LSI_ENABLE();
 521              		.loc 1 232 0
 522 0220 404B     		ldr	r3, .L73
 523 0222 404A     		ldr	r2, .L73
 524 0224 526A     		ldr	r2, [r2, #36]
 525 0226 0121     		movs	r1, #1
 526 0228 0A43     		orrs	r2, r1
 527 022a 5A62     		str	r2, [r3, #36]
 233:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 234:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 235:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 528              		.loc 1 235 0
 529 022c FFF7FEFF 		bl	HAL_GetTick
 530 0230 0300     		movs	r3, r0
 531 0232 3B61     		str	r3, [r7, #16]
 236:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 237:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSI is ready */  
 238:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 532              		.loc 1 238 0
 533 0234 08E0     		b	.L37
 534              	.L38:
 239:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 240:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 535              		.loc 1 240 0
 536 0236 FFF7FEFF 		bl	HAL_GetTick
 537 023a 0200     		movs	r2, r0
 538 023c 3B69     		ldr	r3, [r7, #16]
 539 023e D31A     		subs	r3, r2, r3
 540 0240 022B     		cmp	r3, #2
 541 0242 01D9     		bls	.L37
 241:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 242:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 542              		.loc 1 242 0
 543 0244 0323     		movs	r3, #3
 544 0246 BEE1     		b	.L16
 545              	.L37:
 238:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 546              		.loc 1 238 0
 547 0248 364B     		ldr	r3, .L73
 548 024a 5B6A     		ldr	r3, [r3, #36]
 549 024c 0222     		movs	r2, #2
 550 024e 1340     		ands	r3, r2
 551 0250 F1D0     		beq	.L38
 552 0252 18E0     		b	.L35
 553              	.L36:
 243:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 244:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 245:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 246:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 247:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 248:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable the Internal Low Speed oscillator (LSI). */
 249:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_LSI_DISABLE();
 554              		.loc 1 249 0
 555 0254 334B     		ldr	r3, .L73
 556 0256 334A     		ldr	r2, .L73
 557 0258 526A     		ldr	r2, [r2, #36]
 558 025a 0121     		movs	r1, #1
 559 025c 8A43     		bics	r2, r1
 560 025e 5A62     		str	r2, [r3, #36]
 250:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 251:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 252:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 561              		.loc 1 252 0
 562 0260 FFF7FEFF 		bl	HAL_GetTick
 563 0264 0300     		movs	r3, r0
 564 0266 3B61     		str	r3, [r7, #16]
 253:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 254:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSI is disabled */  
 255:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 565              		.loc 1 255 0
 566 0268 08E0     		b	.L39
 567              	.L40:
 256:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 257:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 568              		.loc 1 257 0
 569 026a FFF7FEFF 		bl	HAL_GetTick
 570 026e 0200     		movs	r2, r0
 571 0270 3B69     		ldr	r3, [r7, #16]
 572 0272 D31A     		subs	r3, r2, r3
 573 0274 022B     		cmp	r3, #2
 574 0276 01D9     		bls	.L39
 258:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 259:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 575              		.loc 1 259 0
 576 0278 0323     		movs	r3, #3
 577 027a A4E1     		b	.L16
 578              	.L39:
 255:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 579              		.loc 1 255 0
 580 027c 294B     		ldr	r3, .L73
 581 027e 5B6A     		ldr	r3, [r3, #36]
 582 0280 0222     		movs	r2, #2
 583 0282 1340     		ands	r3, r2
 584 0284 F1D1     		bne	.L40
 585              	.L35:
 260:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 261:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 262:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 263:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 264:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ LSE Configuration -------------------------*/ 
 265:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 586              		.loc 1 265 0
 587 0286 7B68     		ldr	r3, [r7, #4]
 588 0288 1B68     		ldr	r3, [r3]
 589 028a 0422     		movs	r2, #4
 590 028c 1340     		ands	r3, r2
 591 028e 00D1     		bne	.LCB518
 592 0290 B6E0     		b	.L41	@long jump
 593              	.LCB518:
 594              	.LBB2:
 266:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 267:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     FlagStatus       pwrclkchanged = RESET;
 595              		.loc 1 267 0
 596 0292 1723     		movs	r3, #23
 597 0294 FB18     		adds	r3, r7, r3
 598 0296 0022     		movs	r2, #0
 599 0298 1A70     		strb	r2, [r3]
 268:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 269:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 270:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 271:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 272:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Update LSE configuration in Backup Domain control register    */
 273:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Requires to enable write access to Backup Domain of necessary */
 274:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 600              		.loc 1 274 0
 601 029a 224B     		ldr	r3, .L73
 602 029c DA69     		ldr	r2, [r3, #28]
 603 029e 8023     		movs	r3, #128
 604 02a0 5B05     		lsls	r3, r3, #21
 605 02a2 1340     		ands	r3, r2
 606 02a4 11D1     		bne	.L42
 607              	.LBB3:
 275:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 276:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_PWR_CLK_ENABLE();
 608              		.loc 1 276 0
 609 02a6 1F4B     		ldr	r3, .L73
 610 02a8 1E4A     		ldr	r2, .L73
 611 02aa D269     		ldr	r2, [r2, #28]
 612 02ac 8021     		movs	r1, #128
 613 02ae 4905     		lsls	r1, r1, #21
 614 02b0 0A43     		orrs	r2, r1
 615 02b2 DA61     		str	r2, [r3, #28]
 616 02b4 1B4B     		ldr	r3, .L73
 617 02b6 DA69     		ldr	r2, [r3, #28]
 618 02b8 8023     		movs	r3, #128
 619 02ba 5B05     		lsls	r3, r3, #21
 620 02bc 1340     		ands	r3, r2
 621 02be FB60     		str	r3, [r7, #12]
 622 02c0 FB68     		ldr	r3, [r7, #12]
 623              	.LBE3:
 277:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       pwrclkchanged = SET;
 624              		.loc 1 277 0
 625 02c2 1723     		movs	r3, #23
 626 02c4 FB18     		adds	r3, r7, r3
 627 02c6 0122     		movs	r2, #1
 628 02c8 1A70     		strb	r2, [r3]
 629              	.L42:
 278:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 279:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 280:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 630              		.loc 1 280 0
 631 02ca 194B     		ldr	r3, .L73+12
 632 02cc 1A68     		ldr	r2, [r3]
 633 02ce 8023     		movs	r3, #128
 634 02d0 5B00     		lsls	r3, r3, #1
 635 02d2 1340     		ands	r3, r2
 636 02d4 1AD1     		bne	.L43
 281:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 282:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable write access to Backup domain */
 283:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(PWR->CR, PWR_CR_DBP);
 637              		.loc 1 283 0
 638 02d6 164B     		ldr	r3, .L73+12
 639 02d8 154A     		ldr	r2, .L73+12
 640 02da 1268     		ldr	r2, [r2]
 641 02dc 8021     		movs	r1, #128
 642 02de 4900     		lsls	r1, r1, #1
 643 02e0 0A43     		orrs	r2, r1
 644 02e2 1A60     		str	r2, [r3]
 284:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 285:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait for Backup domain Write protection disable */
 286:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 645              		.loc 1 286 0
 646 02e4 FFF7FEFF 		bl	HAL_GetTick
 647 02e8 0300     		movs	r3, r0
 648 02ea 3B61     		str	r3, [r7, #16]
 287:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 288:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 649              		.loc 1 288 0
 650 02ec 08E0     		b	.L44
 651              	.L45:
 289:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 290:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 652              		.loc 1 290 0
 653 02ee FFF7FEFF 		bl	HAL_GetTick
 654 02f2 0200     		movs	r2, r0
 655 02f4 3B69     		ldr	r3, [r7, #16]
 656 02f6 D31A     		subs	r3, r2, r3
 657 02f8 642B     		cmp	r3, #100
 658 02fa 01D9     		bls	.L44
 291:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 292:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 659              		.loc 1 292 0
 660 02fc 0323     		movs	r3, #3
 661 02fe 62E1     		b	.L16
 662              	.L44:
 288:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 663              		.loc 1 288 0
 664 0300 0B4B     		ldr	r3, .L73+12
 665 0302 1A68     		ldr	r2, [r3]
 666 0304 8023     		movs	r3, #128
 667 0306 5B00     		lsls	r3, r3, #1
 668 0308 1340     		ands	r3, r2
 669 030a F0D0     		beq	.L45
 670              	.L43:
 293:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 294:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 295:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 296:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 297:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Set the new LSE configuration -----------------------------------------*/
 298:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 671              		.loc 1 298 0
 672 030c 7B68     		ldr	r3, [r7, #4]
 673 030e 9B68     		ldr	r3, [r3, #8]
 674 0310 012B     		cmp	r3, #1
 675 0312 0FD1     		bne	.L46
 676              		.loc 1 298 0 is_stmt 0 discriminator 1
 677 0314 034B     		ldr	r3, .L73
 678 0316 034A     		ldr	r2, .L73
 679 0318 126A     		ldr	r2, [r2, #32]
 680 031a 0121     		movs	r1, #1
 681 031c 0A43     		orrs	r2, r1
 682 031e 1A62     		str	r2, [r3, #32]
 683 0320 36E0     		b	.L47
 684              	.L74:
 685 0322 C046     		.align	2
 686              	.L73:
 687 0324 00100240 		.word	1073876992
 688 0328 FFFFFEFF 		.word	-65537
 689 032c FFFFFBFF 		.word	-262145
 690 0330 00700040 		.word	1073770496
 691              	.L46:
 692              		.loc 1 298 0 discriminator 2
 693 0334 7B68     		ldr	r3, [r7, #4]
 694 0336 9B68     		ldr	r3, [r3, #8]
 695 0338 002B     		cmp	r3, #0
 696 033a 0CD1     		bne	.L48
 697              		.loc 1 298 0 discriminator 3
 698 033c A44B     		ldr	r3, .L75
 699 033e A44A     		ldr	r2, .L75
 700 0340 126A     		ldr	r2, [r2, #32]
 701 0342 0121     		movs	r1, #1
 702 0344 8A43     		bics	r2, r1
 703 0346 1A62     		str	r2, [r3, #32]
 704 0348 A14B     		ldr	r3, .L75
 705 034a A14A     		ldr	r2, .L75
 706 034c 126A     		ldr	r2, [r2, #32]
 707 034e 0421     		movs	r1, #4
 708 0350 8A43     		bics	r2, r1
 709 0352 1A62     		str	r2, [r3, #32]
 710 0354 1CE0     		b	.L47
 711              	.L48:
 712              		.loc 1 298 0 discriminator 4
 713 0356 7B68     		ldr	r3, [r7, #4]
 714 0358 9B68     		ldr	r3, [r3, #8]
 715 035a 052B     		cmp	r3, #5
 716 035c 0CD1     		bne	.L49
 717              		.loc 1 298 0 discriminator 5
 718 035e 9C4B     		ldr	r3, .L75
 719 0360 9B4A     		ldr	r2, .L75
 720 0362 126A     		ldr	r2, [r2, #32]
 721 0364 0421     		movs	r1, #4
 722 0366 0A43     		orrs	r2, r1
 723 0368 1A62     		str	r2, [r3, #32]
 724 036a 994B     		ldr	r3, .L75
 725 036c 984A     		ldr	r2, .L75
 726 036e 126A     		ldr	r2, [r2, #32]
 727 0370 0121     		movs	r1, #1
 728 0372 0A43     		orrs	r2, r1
 729 0374 1A62     		str	r2, [r3, #32]
 730 0376 0BE0     		b	.L47
 731              	.L49:
 732              		.loc 1 298 0 discriminator 6
 733 0378 954B     		ldr	r3, .L75
 734 037a 954A     		ldr	r2, .L75
 735 037c 126A     		ldr	r2, [r2, #32]
 736 037e 0121     		movs	r1, #1
 737 0380 8A43     		bics	r2, r1
 738 0382 1A62     		str	r2, [r3, #32]
 739 0384 924B     		ldr	r3, .L75
 740 0386 924A     		ldr	r2, .L75
 741 0388 126A     		ldr	r2, [r2, #32]
 742 038a 0421     		movs	r1, #4
 743 038c 8A43     		bics	r2, r1
 744 038e 1A62     		str	r2, [r3, #32]
 745              	.L47:
 299:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the LSE State */
 300:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 746              		.loc 1 300 0 is_stmt 1
 747 0390 7B68     		ldr	r3, [r7, #4]
 748 0392 9B68     		ldr	r3, [r3, #8]
 749 0394 002B     		cmp	r3, #0
 750 0396 14D0     		beq	.L50
 301:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 302:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 303:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 751              		.loc 1 303 0
 752 0398 FFF7FEFF 		bl	HAL_GetTick
 753 039c 0300     		movs	r3, r0
 754 039e 3B61     		str	r3, [r7, #16]
 304:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 305:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSE is ready */  
 306:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 755              		.loc 1 306 0
 756 03a0 09E0     		b	.L51
 757              	.L52:
 307:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 308:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 758              		.loc 1 308 0
 759 03a2 FFF7FEFF 		bl	HAL_GetTick
 760 03a6 0200     		movs	r2, r0
 761 03a8 3B69     		ldr	r3, [r7, #16]
 762 03aa D31A     		subs	r3, r2, r3
 763 03ac 894A     		ldr	r2, .L75+4
 764 03ae 9342     		cmp	r3, r2
 765 03b0 01D9     		bls	.L51
 309:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 310:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 766              		.loc 1 310 0
 767 03b2 0323     		movs	r3, #3
 768 03b4 07E1     		b	.L16
 769              	.L51:
 306:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 770              		.loc 1 306 0
 771 03b6 864B     		ldr	r3, .L75
 772 03b8 1B6A     		ldr	r3, [r3, #32]
 773 03ba 0222     		movs	r2, #2
 774 03bc 1340     		ands	r3, r2
 775 03be F0D0     		beq	.L52
 776 03c0 13E0     		b	.L53
 777              	.L50:
 311:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 312:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 313:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 314:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 315:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 316:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 317:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 778              		.loc 1 317 0
 779 03c2 FFF7FEFF 		bl	HAL_GetTick
 780 03c6 0300     		movs	r3, r0
 781 03c8 3B61     		str	r3, [r7, #16]
 318:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 319:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSE is disabled */  
 320:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 782              		.loc 1 320 0
 783 03ca 09E0     		b	.L54
 784              	.L55:
 321:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 322:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 785              		.loc 1 322 0
 786 03cc FFF7FEFF 		bl	HAL_GetTick
 787 03d0 0200     		movs	r2, r0
 788 03d2 3B69     		ldr	r3, [r7, #16]
 789 03d4 D31A     		subs	r3, r2, r3
 790 03d6 7F4A     		ldr	r2, .L75+4
 791 03d8 9342     		cmp	r3, r2
 792 03da 01D9     		bls	.L54
 323:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 324:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 793              		.loc 1 324 0
 794 03dc 0323     		movs	r3, #3
 795 03de F2E0     		b	.L16
 796              	.L54:
 320:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 797              		.loc 1 320 0
 798 03e0 7B4B     		ldr	r3, .L75
 799 03e2 1B6A     		ldr	r3, [r3, #32]
 800 03e4 0222     		movs	r2, #2
 801 03e6 1340     		ands	r3, r2
 802 03e8 F0D1     		bne	.L55
 803              	.L53:
 325:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 326:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 327:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 328:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 329:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Require to disable power clock if necessary */
 330:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(pwrclkchanged == SET)
 804              		.loc 1 330 0
 805 03ea 1723     		movs	r3, #23
 806 03ec FB18     		adds	r3, r7, r3
 807 03ee 1B78     		ldrb	r3, [r3]
 808 03f0 012B     		cmp	r3, #1
 809 03f2 05D1     		bne	.L41
 331:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 332:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_PWR_CLK_DISABLE();
 810              		.loc 1 332 0
 811 03f4 764B     		ldr	r3, .L75
 812 03f6 764A     		ldr	r2, .L75
 813 03f8 D269     		ldr	r2, [r2, #28]
 814 03fa 7749     		ldr	r1, .L75+8
 815 03fc 0A40     		ands	r2, r1
 816 03fe DA61     		str	r2, [r3, #28]
 817              	.L41:
 818              	.LBE2:
 333:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 334:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 335:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 336:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- HSI14 Configuration --------------------------*/
 337:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 819              		.loc 1 337 0
 820 0400 7B68     		ldr	r3, [r7, #4]
 821 0402 1B68     		ldr	r3, [r3]
 822 0404 1022     		movs	r2, #16
 823 0406 1340     		ands	r3, r2
 824 0408 63D0     		beq	.L56
 338:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 339:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 340:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
 341:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));
 342:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 343:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the HSI14 State */
 344:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 825              		.loc 1 344 0
 826 040a 7B68     		ldr	r3, [r7, #4]
 827 040c 5B69     		ldr	r3, [r3, #20]
 828 040e 012B     		cmp	r3, #1
 829 0410 2AD1     		bne	.L57
 345:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 346:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable ADC control of the Internal High Speed oscillator HSI14 */
 347:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14ADC_DISABLE();
 830              		.loc 1 347 0
 831 0412 6F4B     		ldr	r3, .L75
 832 0414 6E4A     		ldr	r2, .L75
 833 0416 526B     		ldr	r2, [r2, #52]
 834 0418 0421     		movs	r1, #4
 835 041a 0A43     		orrs	r2, r1
 836 041c 5A63     		str	r2, [r3, #52]
 348:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 349:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable the Internal High Speed oscillator (HSI). */
 350:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_ENABLE();
 837              		.loc 1 350 0
 838 041e 6C4B     		ldr	r3, .L75
 839 0420 6B4A     		ldr	r2, .L75
 840 0422 526B     		ldr	r2, [r2, #52]
 841 0424 0121     		movs	r1, #1
 842 0426 0A43     		orrs	r2, r1
 843 0428 5A63     		str	r2, [r3, #52]
 351:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 352:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 353:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 844              		.loc 1 353 0
 845 042a FFF7FEFF 		bl	HAL_GetTick
 846 042e 0300     		movs	r3, r0
 847 0430 3B61     		str	r3, [r7, #16]
 354:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 355:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till HSI is ready */  
 356:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 848              		.loc 1 356 0
 849 0432 08E0     		b	.L58
 850              	.L59:
 357:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 358:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 851              		.loc 1 358 0
 852 0434 FFF7FEFF 		bl	HAL_GetTick
 853 0438 0200     		movs	r2, r0
 854 043a 3B69     		ldr	r3, [r7, #16]
 855 043c D31A     		subs	r3, r2, r3
 856 043e 022B     		cmp	r3, #2
 857 0440 01D9     		bls	.L58
 359:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 360:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 858              		.loc 1 360 0
 859 0442 0323     		movs	r3, #3
 860 0444 BFE0     		b	.L16
 861              	.L58:
 356:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 862              		.loc 1 356 0
 863 0446 624B     		ldr	r3, .L75
 864 0448 5B6B     		ldr	r3, [r3, #52]
 865 044a 0222     		movs	r2, #2
 866 044c 1340     		ands	r3, r2
 867 044e F1D0     		beq	.L59
 361:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }      
 362:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       } 
 363:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 364:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
 365:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 868              		.loc 1 365 0
 869 0450 5F4A     		ldr	r2, .L75
 870 0452 5F4B     		ldr	r3, .L75
 871 0454 5B6B     		ldr	r3, [r3, #52]
 872 0456 F821     		movs	r1, #248
 873 0458 8B43     		bics	r3, r1
 874 045a 1900     		movs	r1, r3
 875 045c 7B68     		ldr	r3, [r7, #4]
 876 045e 9B69     		ldr	r3, [r3, #24]
 877 0460 DB00     		lsls	r3, r3, #3
 878 0462 0B43     		orrs	r3, r1
 879 0464 5363     		str	r3, [r2, #52]
 880 0466 34E0     		b	.L56
 881              	.L57:
 366:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 367:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 882              		.loc 1 367 0
 883 0468 7B68     		ldr	r3, [r7, #4]
 884 046a 5B69     		ldr	r3, [r3, #20]
 885 046c 0533     		adds	r3, r3, #5
 886 046e 11D1     		bne	.L60
 368:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 369:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable ADC control of the Internal High Speed oscillator HSI14 */
 370:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14ADC_ENABLE();
 887              		.loc 1 370 0
 888 0470 574B     		ldr	r3, .L75
 889 0472 574A     		ldr	r2, .L75
 890 0474 526B     		ldr	r2, [r2, #52]
 891 0476 0421     		movs	r1, #4
 892 0478 8A43     		bics	r2, r1
 893 047a 5A63     		str	r2, [r3, #52]
 371:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 372:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
 373:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 894              		.loc 1 373 0
 895 047c 544A     		ldr	r2, .L75
 896 047e 544B     		ldr	r3, .L75
 897 0480 5B6B     		ldr	r3, [r3, #52]
 898 0482 F821     		movs	r1, #248
 899 0484 8B43     		bics	r3, r1
 900 0486 1900     		movs	r1, r3
 901 0488 7B68     		ldr	r3, [r7, #4]
 902 048a 9B69     		ldr	r3, [r3, #24]
 903 048c DB00     		lsls	r3, r3, #3
 904 048e 0B43     		orrs	r3, r1
 905 0490 5363     		str	r3, [r2, #52]
 906 0492 1EE0     		b	.L56
 907              	.L60:
 374:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 375:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 376:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 377:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable ADC control of the Internal High Speed oscillator HSI14 */
 378:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14ADC_DISABLE();
 908              		.loc 1 378 0
 909 0494 4E4B     		ldr	r3, .L75
 910 0496 4E4A     		ldr	r2, .L75
 911 0498 526B     		ldr	r2, [r2, #52]
 912 049a 0421     		movs	r1, #4
 913 049c 0A43     		orrs	r2, r1
 914 049e 5A63     		str	r2, [r3, #52]
 379:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 380:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable the Internal High Speed oscillator (HSI). */
 381:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_DISABLE();
 915              		.loc 1 381 0
 916 04a0 4B4B     		ldr	r3, .L75
 917 04a2 4B4A     		ldr	r2, .L75
 918 04a4 526B     		ldr	r2, [r2, #52]
 919 04a6 0121     		movs	r1, #1
 920 04a8 8A43     		bics	r2, r1
 921 04aa 5A63     		str	r2, [r3, #52]
 382:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 383:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 384:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 922              		.loc 1 384 0
 923 04ac FFF7FEFF 		bl	HAL_GetTick
 924 04b0 0300     		movs	r3, r0
 925 04b2 3B61     		str	r3, [r7, #16]
 385:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 386:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till HSI is ready */  
 387:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 926              		.loc 1 387 0
 927 04b4 08E0     		b	.L61
 928              	.L62:
 388:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 389:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 929              		.loc 1 389 0
 930 04b6 FFF7FEFF 		bl	HAL_GetTick
 931 04ba 0200     		movs	r2, r0
 932 04bc 3B69     		ldr	r3, [r7, #16]
 933 04be D31A     		subs	r3, r2, r3
 934 04c0 022B     		cmp	r3, #2
 935 04c2 01D9     		bls	.L61
 390:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 391:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 936              		.loc 1 391 0
 937 04c4 0323     		movs	r3, #3
 938 04c6 7EE0     		b	.L16
 939              	.L61:
 387:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 940              		.loc 1 387 0
 941 04c8 414B     		ldr	r3, .L75
 942 04ca 5B6B     		ldr	r3, [r3, #52]
 943 04cc 0222     		movs	r2, #2
 944 04ce 1340     		ands	r3, r2
 945 04d0 F1D1     		bne	.L62
 946              	.L56:
 392:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 393:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 394:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 395:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 396:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 397:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(RCC_HSI48_SUPPORT)
 398:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- HSI48 Configuration --------------------------*/
 399:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 400:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 401:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 402:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 403:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 404:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* When the HSI48 is used as system clock it is not allowed to be disabled */
 405:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 406:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSC
 407:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 408:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_
 409:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 410:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 411:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 412:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 413:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 414:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 415:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI48 State */
 416:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 417:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 418:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Enable the Internal High Speed oscillator (HSI48). */
 419:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI48_ENABLE();
 420:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 421:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 422:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 423:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 424:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI48 is ready */  
 425:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 426:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 427:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 428:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 429:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 430:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 431:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         } 
 432:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 433:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 434:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 435:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the Internal High Speed oscillator (HSI48). */
 436:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI48_DISABLE();
 437:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 438:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 439:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 440:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 441:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI48 is ready */  
 442:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 443:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 444:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 445:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 446:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 447:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 448:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 449:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 450:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 451:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 452:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* RCC_HSI48_SUPPORT */
 453:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        
 454:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------------- PLL Configuration -----------------------*/
 455:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 456:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 457:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 947              		.loc 1 457 0
 948 04d2 7B68     		ldr	r3, [r7, #4]
 949 04d4 1B6A     		ldr	r3, [r3, #32]
 950 04d6 002B     		cmp	r3, #0
 951 04d8 00D1     		bne	.LCB869
 952 04da 73E0     		b	.L63	@long jump
 953              	.LCB869:
 458:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 459:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if the PLL is used as system clock or not */
 460:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 954              		.loc 1 460 0
 955 04dc 3C4B     		ldr	r3, .L75
 956 04de 5B68     		ldr	r3, [r3, #4]
 957 04e0 0C22     		movs	r2, #12
 958 04e2 1340     		ands	r3, r2
 959 04e4 082B     		cmp	r3, #8
 960 04e6 00D1     		bne	.LCB875
 961 04e8 6AE0     		b	.L64	@long jump
 962              	.LCB875:
 461:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     { 
 462:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 963              		.loc 1 462 0
 964 04ea 7B68     		ldr	r3, [r7, #4]
 965 04ec 1B6A     		ldr	r3, [r3, #32]
 966 04ee 022B     		cmp	r3, #2
 967 04f0 4BD1     		bne	.L65
 463:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 464:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Check the parameters */
 465:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 466:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
 467:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_RCC_PREDIV(RCC_OscInitStruct->PLL.PREDIV));
 468:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 469:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the main PLL. */
 470:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_DISABLE();
 968              		.loc 1 470 0
 969 04f2 374B     		ldr	r3, .L75
 970 04f4 364A     		ldr	r2, .L75
 971 04f6 1268     		ldr	r2, [r2]
 972 04f8 3849     		ldr	r1, .L75+12
 973 04fa 0A40     		ands	r2, r1
 974 04fc 1A60     		str	r2, [r3]
 471:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 472:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 473:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 975              		.loc 1 473 0
 976 04fe FFF7FEFF 		bl	HAL_GetTick
 977 0502 0300     		movs	r3, r0
 978 0504 3B61     		str	r3, [r7, #16]
 474:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 475:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till PLL is disabled */
 476:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 979              		.loc 1 476 0
 980 0506 08E0     		b	.L66
 981              	.L67:
 477:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 478:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 982              		.loc 1 478 0
 983 0508 FFF7FEFF 		bl	HAL_GetTick
 984 050c 0200     		movs	r2, r0
 985 050e 3B69     		ldr	r3, [r7, #16]
 986 0510 D31A     		subs	r3, r2, r3
 987 0512 022B     		cmp	r3, #2
 988 0514 01D9     		bls	.L66
 479:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 480:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 989              		.loc 1 480 0
 990 0516 0323     		movs	r3, #3
 991 0518 55E0     		b	.L16
 992              	.L66:
 476:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 993              		.loc 1 476 0
 994 051a 2D4B     		ldr	r3, .L75
 995 051c 1A68     		ldr	r2, [r3]
 996 051e 8023     		movs	r3, #128
 997 0520 9B04     		lsls	r3, r3, #18
 998 0522 1340     		ands	r3, r2
 999 0524 F0D1     		bne	.L67
 481:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 482:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 483:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 484:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure the main PLL clock source, predivider and multiplication factor. */
 485:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 1000              		.loc 1 485 0
 1001 0526 2A4A     		ldr	r2, .L75
 1002 0528 294B     		ldr	r3, .L75
 1003 052a DB6A     		ldr	r3, [r3, #44]
 1004 052c 0F21     		movs	r1, #15
 1005 052e 8B43     		bics	r3, r1
 1006 0530 1900     		movs	r1, r3
 1007 0532 7B68     		ldr	r3, [r7, #4]
 1008 0534 DB6A     		ldr	r3, [r3, #44]
 1009 0536 0B43     		orrs	r3, r1
 1010 0538 D362     		str	r3, [r2, #44]
 1011 053a 254A     		ldr	r2, .L75
 1012 053c 244B     		ldr	r3, .L75
 1013 053e 5B68     		ldr	r3, [r3, #4]
 1014 0540 2749     		ldr	r1, .L75+16
 1015 0542 1940     		ands	r1, r3
 1016 0544 7B68     		ldr	r3, [r7, #4]
 1017 0546 986A     		ldr	r0, [r3, #40]
 1018 0548 7B68     		ldr	r3, [r7, #4]
 1019 054a 5B6A     		ldr	r3, [r3, #36]
 1020 054c 0343     		orrs	r3, r0
 1021 054e 0B43     		orrs	r3, r1
 1022 0550 5360     		str	r3, [r2, #4]
 486:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                              RCC_OscInitStruct->PLL.PREDIV,
 487:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                              RCC_OscInitStruct->PLL.PLLMUL);
 488:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Enable the main PLL. */
 489:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_ENABLE();
 1023              		.loc 1 489 0
 1024 0552 1F4B     		ldr	r3, .L75
 1025 0554 1E4A     		ldr	r2, .L75
 1026 0556 1268     		ldr	r2, [r2]
 1027 0558 8021     		movs	r1, #128
 1028 055a 4904     		lsls	r1, r1, #17
 1029 055c 0A43     		orrs	r2, r1
 1030 055e 1A60     		str	r2, [r3]
 490:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 491:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 492:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 1031              		.loc 1 492 0
 1032 0560 FFF7FEFF 		bl	HAL_GetTick
 1033 0564 0300     		movs	r3, r0
 1034 0566 3B61     		str	r3, [r7, #16]
 493:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 494:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till PLL is ready */
 495:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 1035              		.loc 1 495 0
 1036 0568 08E0     		b	.L68
 1037              	.L69:
 496:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 497:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 1038              		.loc 1 497 0
 1039 056a FFF7FEFF 		bl	HAL_GetTick
 1040 056e 0200     		movs	r2, r0
 1041 0570 3B69     		ldr	r3, [r7, #16]
 1042 0572 D31A     		subs	r3, r2, r3
 1043 0574 022B     		cmp	r3, #2
 1044 0576 01D9     		bls	.L68
 498:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 499:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 1045              		.loc 1 499 0
 1046 0578 0323     		movs	r3, #3
 1047 057a 24E0     		b	.L16
 1048              	.L68:
 495:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1049              		.loc 1 495 0
 1050 057c 144B     		ldr	r3, .L75
 1051 057e 1A68     		ldr	r2, [r3]
 1052 0580 8023     		movs	r3, #128
 1053 0582 9B04     		lsls	r3, r3, #18
 1054 0584 1340     		ands	r3, r2
 1055 0586 F0D0     		beq	.L69
 1056 0588 1CE0     		b	.L63
 1057              	.L65:
 500:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 501:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 502:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 503:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 504:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 505:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the main PLL. */
 506:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_DISABLE();
 1058              		.loc 1 506 0
 1059 058a 114B     		ldr	r3, .L75
 1060 058c 104A     		ldr	r2, .L75
 1061 058e 1268     		ldr	r2, [r2]
 1062 0590 1249     		ldr	r1, .L75+12
 1063 0592 0A40     		ands	r2, r1
 1064 0594 1A60     		str	r2, [r3]
 507:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  
 508:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 509:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 1065              		.loc 1 509 0
 1066 0596 FFF7FEFF 		bl	HAL_GetTick
 1067 059a 0300     		movs	r3, r0
 1068 059c 3B61     		str	r3, [r7, #16]
 510:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 511:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till PLL is disabled */  
 512:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 1069              		.loc 1 512 0
 1070 059e 08E0     		b	.L70
 1071              	.L71:
 513:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 514:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 1072              		.loc 1 514 0
 1073 05a0 FFF7FEFF 		bl	HAL_GetTick
 1074 05a4 0200     		movs	r2, r0
 1075 05a6 3B69     		ldr	r3, [r7, #16]
 1076 05a8 D31A     		subs	r3, r2, r3
 1077 05aa 022B     		cmp	r3, #2
 1078 05ac 01D9     		bls	.L70
 515:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 516:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 1079              		.loc 1 516 0
 1080 05ae 0323     		movs	r3, #3
 1081 05b0 09E0     		b	.L16
 1082              	.L70:
 512:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1083              		.loc 1 512 0
 1084 05b2 074B     		ldr	r3, .L75
 1085 05b4 1A68     		ldr	r2, [r3]
 1086 05b6 8023     		movs	r3, #128
 1087 05b8 9B04     		lsls	r3, r3, #18
 1088 05ba 1340     		ands	r3, r2
 1089 05bc F0D1     		bne	.L71
 1090 05be 01E0     		b	.L63
 1091              	.L64:
 517:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 518:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 519:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 520:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 521:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 522:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 523:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_ERROR;
 1092              		.loc 1 523 0
 1093 05c0 0123     		movs	r3, #1
 1094 05c2 00E0     		b	.L16
 1095              	.L63:
 524:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 525:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 526:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 527:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 1096              		.loc 1 527 0
 1097 05c4 0023     		movs	r3, #0
 1098              	.L16:
 528:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 1099              		.loc 1 528 0
 1100 05c6 1800     		movs	r0, r3
 1101 05c8 BD46     		mov	sp, r7
 1102 05ca 06B0     		add	sp, sp, #24
 1103              		@ sp needed
 1104 05cc 80BD     		pop	{r7, pc}
 1105              	.L76:
 1106 05ce C046     		.align	2
 1107              	.L75:
 1108 05d0 00100240 		.word	1073876992
 1109 05d4 88130000 		.word	5000
 1110 05d8 FFFFFFEF 		.word	-268435457
 1111 05dc FFFFFFFE 		.word	-16777217
 1112 05e0 FFFFC2FF 		.word	-3997697
 1113              		.cfi_endproc
 1114              	.LFE39:
 1116              		.section	.text.HAL_RCC_ClockConfig,"ax",%progbits
 1117              		.align	2
 1118              		.global	HAL_RCC_ClockConfig
 1119              		.code	16
 1120              		.thumb_func
 1122              	HAL_RCC_ClockConfig:
 1123              	.LFB40:
 529:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 530:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
 531:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified 
 532:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         parameters in the RCC_ClkInitStruct.
 533:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
 534:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         contains the configuration information for the RCC peripheral.
 535:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  FLatency FLASH Latency                   
 536:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *          The value of this parameter depend on device used within the same series
 537:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
 538:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         and updated by @ref HAL_RCC_GetHCLKFreq() function called within this function
 539:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
 540:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   The HSI is used (enabled by hardware) as system clock source after
 541:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case
 542:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         of failure of the HSE used directly or indirectly as system clock
 543:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         (if the Clock Security System CSS is enabled).
 544:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *           
 545:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   A switch from one clock source to another occurs only if the target
 546:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         clock source is ready (clock stable after start-up delay or PLL locked). 
 547:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         If a clock source which is not yet ready is selected, the switch will
 548:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         occur when the clock source will be ready. 
 549:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
 550:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         currently used as system clock source.
 551:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
 552:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
 553:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
 554:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 1124              		.loc 1 554 0
 1125              		.cfi_startproc
 1126              		@ args = 0, pretend = 0, frame = 16
 1127              		@ frame_needed = 1, uses_anonymous_args = 0
 1128 0000 80B5     		push	{r7, lr}
 1129              	.LCFI11:
 1130              		.cfi_def_cfa_offset 8
 1131              		.cfi_offset 7, -8
 1132              		.cfi_offset 14, -4
 1133 0002 84B0     		sub	sp, sp, #16
 1134              	.LCFI12:
 1135              		.cfi_def_cfa_offset 24
 1136 0004 00AF     		add	r7, sp, #0
 1137              	.LCFI13:
 1138              		.cfi_def_cfa_register 7
 1139 0006 7860     		str	r0, [r7, #4]
 1140 0008 3960     		str	r1, [r7]
 555:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
 1141              		.loc 1 555 0
 1142 000a 0023     		movs	r3, #0
 1143 000c FB60     		str	r3, [r7, #12]
 556:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 557:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 558:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(RCC_ClkInitStruct != NULL);
 559:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 560:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_FLASH_LATENCY(FLatency));
 561:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 562:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
 563:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   must be correctly programmed according to the frequency of the CPU clock 
 564:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     (HCLK) of the device. */
 565:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 566:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Increasing the number of wait states because of higher CPU frequency */
 567:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 1144              		.loc 1 567 0
 1145 000e 634B     		ldr	r3, .L95
 1146 0010 1B68     		ldr	r3, [r3]
 1147 0012 0122     		movs	r2, #1
 1148 0014 1A40     		ands	r2, r3
 1149 0016 3B68     		ldr	r3, [r7]
 1150 0018 9A42     		cmp	r2, r3
 1151 001a 11D2     		bcs	.L78
 568:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {    
 569:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
 570:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_FLASH_SET_LATENCY(FLatency);
 1152              		.loc 1 570 0
 1153 001c 5F4B     		ldr	r3, .L95
 1154 001e 5F4A     		ldr	r2, .L95
 1155 0020 1268     		ldr	r2, [r2]
 1156 0022 0121     		movs	r1, #1
 1157 0024 8A43     		bics	r2, r1
 1158 0026 1100     		movs	r1, r2
 1159 0028 3A68     		ldr	r2, [r7]
 1160 002a 0A43     		orrs	r2, r1
 1161 002c 1A60     		str	r2, [r3]
 571:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 572:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check that the new number of wait states is taken into account to access the Flash
 573:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     memory by reading the FLASH_ACR register */
 574:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 1162              		.loc 1 574 0
 1163 002e 5B4B     		ldr	r3, .L95
 1164 0030 1B68     		ldr	r3, [r3]
 1165 0032 0122     		movs	r2, #1
 1166 0034 1A40     		ands	r2, r3
 1167 0036 3B68     		ldr	r3, [r7]
 1168 0038 9A42     		cmp	r2, r3
 1169 003a 01D0     		beq	.L78
 575:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 576:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_ERROR;
 1170              		.loc 1 576 0
 1171 003c 0123     		movs	r3, #1
 1172 003e A8E0     		b	.L79
 1173              	.L78:
 577:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 578:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 579:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 580:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- HCLK Configuration --------------------------*/
 581:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 1174              		.loc 1 581 0
 1175 0040 7B68     		ldr	r3, [r7, #4]
 1176 0042 1B68     		ldr	r3, [r3]
 1177 0044 0222     		movs	r2, #2
 1178 0046 1340     		ands	r3, r2
 1179 0048 09D0     		beq	.L80
 582:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 583:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 584:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 1180              		.loc 1 584 0
 1181 004a 554A     		ldr	r2, .L95+4
 1182 004c 544B     		ldr	r3, .L95+4
 1183 004e 5B68     		ldr	r3, [r3, #4]
 1184 0050 F021     		movs	r1, #240
 1185 0052 8B43     		bics	r3, r1
 1186 0054 1900     		movs	r1, r3
 1187 0056 7B68     		ldr	r3, [r7, #4]
 1188 0058 9B68     		ldr	r3, [r3, #8]
 1189 005a 0B43     		orrs	r3, r1
 1190 005c 5360     		str	r3, [r2, #4]
 1191              	.L80:
 585:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 586:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 587:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------- SYSCLK Configuration ---------------------------*/ 
 588:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 1192              		.loc 1 588 0
 1193 005e 7B68     		ldr	r3, [r7, #4]
 1194 0060 1B68     		ldr	r3, [r3]
 1195 0062 0122     		movs	r2, #1
 1196 0064 1340     		ands	r3, r2
 1197 0066 00D1     		bne	.LCB1103
 1198 0068 67E0     		b	.L81	@long jump
 1199              	.LCB1103:
 589:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {    
 590:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 591:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 592:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* HSE is selected as System Clock Source */
 593:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 1200              		.loc 1 593 0
 1201 006a 7B68     		ldr	r3, [r7, #4]
 1202 006c 5B68     		ldr	r3, [r3, #4]
 1203 006e 012B     		cmp	r3, #1
 1204 0070 07D1     		bne	.L82
 594:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 595:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSE ready flag */  
 596:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 1205              		.loc 1 596 0
 1206 0072 4B4B     		ldr	r3, .L95+4
 1207 0074 1A68     		ldr	r2, [r3]
 1208 0076 8023     		movs	r3, #128
 1209 0078 9B02     		lsls	r3, r3, #10
 1210 007a 1340     		ands	r3, r2
 1211 007c 14D1     		bne	.L83
 597:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 598:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 1212              		.loc 1 598 0
 1213 007e 0123     		movs	r3, #1
 1214 0080 87E0     		b	.L79
 1215              	.L82:
 599:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 600:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 601:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* PLL is selected as System Clock Source */
 602:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 1216              		.loc 1 602 0
 1217 0082 7B68     		ldr	r3, [r7, #4]
 1218 0084 5B68     		ldr	r3, [r3, #4]
 1219 0086 022B     		cmp	r3, #2
 1220 0088 07D1     		bne	.L84
 603:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 604:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the PLL ready flag */  
 605:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 1221              		.loc 1 605 0
 1222 008a 454B     		ldr	r3, .L95+4
 1223 008c 1A68     		ldr	r2, [r3]
 1224 008e 8023     		movs	r3, #128
 1225 0090 9B04     		lsls	r3, r3, #18
 1226 0092 1340     		ands	r3, r2
 1227 0094 08D1     		bne	.L83
 606:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 607:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 1228              		.loc 1 607 0
 1229 0096 0123     		movs	r3, #1
 1230 0098 7BE0     		b	.L79
 1231              	.L84:
 608:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 609:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 610:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(RCC_CFGR_SWS_HSI48)
 611:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* HSI48 is selected as System Clock Source */
 612:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 613:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 614:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI48 ready flag */
 615:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 616:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 617:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 618:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 619:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 620:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* RCC_CFGR_SWS_HSI48 */
 621:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* HSI is selected as System Clock Source */
 622:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 623:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 624:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI ready flag */  
 625:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 1232              		.loc 1 625 0
 1233 009a 414B     		ldr	r3, .L95+4
 1234 009c 1B68     		ldr	r3, [r3]
 1235 009e 0222     		movs	r2, #2
 1236 00a0 1340     		ands	r3, r2
 1237 00a2 01D1     		bne	.L83
 626:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 627:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 1238              		.loc 1 627 0
 1239 00a4 0123     		movs	r3, #1
 1240 00a6 74E0     		b	.L79
 1241              	.L83:
 628:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 629:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 630:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 1242              		.loc 1 630 0
 1243 00a8 3D4A     		ldr	r2, .L95+4
 1244 00aa 3D4B     		ldr	r3, .L95+4
 1245 00ac 5B68     		ldr	r3, [r3, #4]
 1246 00ae 0321     		movs	r1, #3
 1247 00b0 8B43     		bics	r3, r1
 1248 00b2 1900     		movs	r1, r3
 1249 00b4 7B68     		ldr	r3, [r7, #4]
 1250 00b6 5B68     		ldr	r3, [r3, #4]
 1251 00b8 0B43     		orrs	r3, r1
 1252 00ba 5360     		str	r3, [r2, #4]
 631:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 632:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Get Start Tick */
 633:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     tickstart = HAL_GetTick();
 1253              		.loc 1 633 0
 1254 00bc FFF7FEFF 		bl	HAL_GetTick
 1255 00c0 0300     		movs	r3, r0
 1256 00c2 FB60     		str	r3, [r7, #12]
 634:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 635:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 1257              		.loc 1 635 0
 1258 00c4 7B68     		ldr	r3, [r7, #4]
 1259 00c6 5B68     		ldr	r3, [r3, #4]
 1260 00c8 012B     		cmp	r3, #1
 1261 00ca 11D1     		bne	.L85
 636:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 637:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 1262              		.loc 1 637 0
 1263 00cc 09E0     		b	.L86
 1264              	.L87:
 638:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 639:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 1265              		.loc 1 639 0
 1266 00ce FFF7FEFF 		bl	HAL_GetTick
 1267 00d2 0200     		movs	r2, r0
 1268 00d4 FB68     		ldr	r3, [r7, #12]
 1269 00d6 D31A     		subs	r3, r2, r3
 1270 00d8 324A     		ldr	r2, .L95+8
 1271 00da 9342     		cmp	r3, r2
 1272 00dc 01D9     		bls	.L86
 640:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 641:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1273              		.loc 1 641 0
 1274 00de 0323     		movs	r3, #3
 1275 00e0 57E0     		b	.L79
 1276              	.L86:
 637:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1277              		.loc 1 637 0
 1278 00e2 2F4B     		ldr	r3, .L95+4
 1279 00e4 5B68     		ldr	r3, [r3, #4]
 1280 00e6 0C22     		movs	r2, #12
 1281 00e8 1340     		ands	r3, r2
 1282 00ea 042B     		cmp	r3, #4
 1283 00ec EFD1     		bne	.L87
 1284 00ee 24E0     		b	.L81
 1285              	.L85:
 642:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 643:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 644:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 645:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 1286              		.loc 1 645 0
 1287 00f0 7B68     		ldr	r3, [r7, #4]
 1288 00f2 5B68     		ldr	r3, [r3, #4]
 1289 00f4 022B     		cmp	r3, #2
 1290 00f6 1BD1     		bne	.L91
 646:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 647:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 1291              		.loc 1 647 0
 1292 00f8 09E0     		b	.L89
 1293              	.L90:
 648:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 649:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 1294              		.loc 1 649 0
 1295 00fa FFF7FEFF 		bl	HAL_GetTick
 1296 00fe 0200     		movs	r2, r0
 1297 0100 FB68     		ldr	r3, [r7, #12]
 1298 0102 D31A     		subs	r3, r2, r3
 1299 0104 274A     		ldr	r2, .L95+8
 1300 0106 9342     		cmp	r3, r2
 1301 0108 01D9     		bls	.L89
 650:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 651:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1302              		.loc 1 651 0
 1303 010a 0323     		movs	r3, #3
 1304 010c 41E0     		b	.L79
 1305              	.L89:
 647:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1306              		.loc 1 647 0
 1307 010e 244B     		ldr	r3, .L95+4
 1308 0110 5B68     		ldr	r3, [r3, #4]
 1309 0112 0C22     		movs	r2, #12
 1310 0114 1340     		ands	r3, r2
 1311 0116 082B     		cmp	r3, #8
 1312 0118 EFD1     		bne	.L90
 1313 011a 0EE0     		b	.L81
 1314              	.L92:
 652:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 653:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 654:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 655:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(RCC_CFGR_SWS_HSI48)
 656:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 657:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 658:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI48)
 659:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 660:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 661:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 662:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 663:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 664:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 665:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 666:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* RCC_CFGR_SWS_HSI48 */
 667:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 668:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 669:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 670:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 671:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 1315              		.loc 1 671 0
 1316 011c FFF7FEFF 		bl	HAL_GetTick
 1317 0120 0200     		movs	r2, r0
 1318 0122 FB68     		ldr	r3, [r7, #12]
 1319 0124 D31A     		subs	r3, r2, r3
 1320 0126 1F4A     		ldr	r2, .L95+8
 1321 0128 9342     		cmp	r3, r2
 1322 012a 01D9     		bls	.L91
 672:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 673:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1323              		.loc 1 673 0
 1324 012c 0323     		movs	r3, #3
 1325 012e 30E0     		b	.L79
 1326              	.L91:
 669:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1327              		.loc 1 669 0
 1328 0130 1B4B     		ldr	r3, .L95+4
 1329 0132 5B68     		ldr	r3, [r3, #4]
 1330 0134 0C22     		movs	r2, #12
 1331 0136 1340     		ands	r3, r2
 1332 0138 F0D1     		bne	.L92
 1333              	.L81:
 674:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 675:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 676:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }      
 677:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }    
 678:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Decreasing the number of wait states because of lower CPU frequency */
 679:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 1334              		.loc 1 679 0
 1335 013a 184B     		ldr	r3, .L95
 1336 013c 1B68     		ldr	r3, [r3]
 1337 013e 0122     		movs	r2, #1
 1338 0140 1A40     		ands	r2, r3
 1339 0142 3B68     		ldr	r3, [r7]
 1340 0144 9A42     		cmp	r2, r3
 1341 0146 11D9     		bls	.L93
 680:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {    
 681:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
 682:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_FLASH_SET_LATENCY(FLatency);
 1342              		.loc 1 682 0
 1343 0148 144B     		ldr	r3, .L95
 1344 014a 144A     		ldr	r2, .L95
 1345 014c 1268     		ldr	r2, [r2]
 1346 014e 0121     		movs	r1, #1
 1347 0150 8A43     		bics	r2, r1
 1348 0152 1100     		movs	r1, r2
 1349 0154 3A68     		ldr	r2, [r7]
 1350 0156 0A43     		orrs	r2, r1
 1351 0158 1A60     		str	r2, [r3]
 683:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 684:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check that the new number of wait states is taken into account to access the Flash
 685:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     memory by reading the FLASH_ACR register */
 686:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 1352              		.loc 1 686 0
 1353 015a 104B     		ldr	r3, .L95
 1354 015c 1B68     		ldr	r3, [r3]
 1355 015e 0122     		movs	r2, #1
 1356 0160 1A40     		ands	r2, r3
 1357 0162 3B68     		ldr	r3, [r7]
 1358 0164 9A42     		cmp	r2, r3
 1359 0166 01D0     		beq	.L93
 687:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 688:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_ERROR;
 1360              		.loc 1 688 0
 1361 0168 0123     		movs	r3, #1
 1362 016a 12E0     		b	.L79
 1363              	.L93:
 689:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 690:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }    
 691:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 692:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- PCLK1 Configuration ---------------------------*/ 
 693:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 1364              		.loc 1 693 0
 1365 016c 7B68     		ldr	r3, [r7, #4]
 1366 016e 1B68     		ldr	r3, [r3]
 1367 0170 0422     		movs	r2, #4
 1368 0172 1340     		ands	r3, r2
 1369 0174 08D0     		beq	.L94
 694:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 695:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 696:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 1370              		.loc 1 696 0
 1371 0176 0A4A     		ldr	r2, .L95+4
 1372 0178 094B     		ldr	r3, .L95+4
 1373 017a 5B68     		ldr	r3, [r3, #4]
 1374 017c 0A49     		ldr	r1, .L95+12
 1375 017e 1940     		ands	r1, r3
 1376 0180 7B68     		ldr	r3, [r7, #4]
 1377 0182 DB68     		ldr	r3, [r3, #12]
 1378 0184 0B43     		orrs	r3, r1
 1379 0186 5360     		str	r3, [r2, #4]
 1380              	.L94:
 697:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 698:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 699:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Update the SystemCoreClock global variable */
 700:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   //SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_
 701:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   SystemCoreClock = 7372800;
 1381              		.loc 1 701 0
 1382 0188 084B     		ldr	r3, .L95+16
 1383 018a E122     		movs	r2, #225
 1384 018c D203     		lsls	r2, r2, #15
 1385 018e 1A60     		str	r2, [r3]
 702:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 703:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure the source of time base considering new system clocks settings*/
 704:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   //HAL_InitTick (TICK_INT_PRIORITY);
 705:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 706:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 1386              		.loc 1 706 0
 1387 0190 0023     		movs	r3, #0
 1388              	.L79:
 707:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 1389              		.loc 1 707 0
 1390 0192 1800     		movs	r0, r3
 1391 0194 BD46     		mov	sp, r7
 1392 0196 04B0     		add	sp, sp, #16
 1393              		@ sp needed
 1394 0198 80BD     		pop	{r7, pc}
 1395              	.L96:
 1396 019a C046     		.align	2
 1397              	.L95:
 1398 019c 00200240 		.word	1073881088
 1399 01a0 00100240 		.word	1073876992
 1400 01a4 88130000 		.word	5000
 1401 01a8 FFF8FFFF 		.word	-1793
 1402 01ac 00000000 		.word	SystemCoreClock
 1403              		.cfi_endproc
 1404              	.LFE40:
 1406              		.section	.text.HAL_RCCEx_PeriphCLKConfig,"ax",%progbits
 1407              		.align	2
 1408              		.global	HAL_RCCEx_PeriphCLKConfig
 1409              		.code	16
 1410              		.thumb_func
 1412              	HAL_RCCEx_PeriphCLKConfig:
 1413              	.LFB41:
 708:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 709:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
 710:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 1414              		.loc 1 710 0
 1415              		.cfi_startproc
 1416              		@ args = 0, pretend = 0, frame = 24
 1417              		@ frame_needed = 1, uses_anonymous_args = 0
 1418 0000 80B5     		push	{r7, lr}
 1419              	.LCFI14:
 1420              		.cfi_def_cfa_offset 8
 1421              		.cfi_offset 7, -8
 1422              		.cfi_offset 14, -4
 1423 0002 86B0     		sub	sp, sp, #24
 1424              	.LCFI15:
 1425              		.cfi_def_cfa_offset 32
 1426 0004 00AF     		add	r7, sp, #0
 1427              	.LCFI16:
 1428              		.cfi_def_cfa_register 7
 1429 0006 7860     		str	r0, [r7, #4]
 711:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
 1430              		.loc 1 711 0
 1431 0008 0023     		movs	r3, #0
 1432 000a 3B61     		str	r3, [r7, #16]
 712:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t temp_reg = 0U;
 1433              		.loc 1 712 0
 1434 000c 0023     		movs	r3, #0
 1435 000e FB60     		str	r3, [r7, #12]
 713:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 714:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 715:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 716:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 717:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*---------------------------- RTC configuration -------------------------------*/
 718:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 1436              		.loc 1 718 0
 1437 0010 7B68     		ldr	r3, [r7, #4]
 1438 0012 1A68     		ldr	r2, [r3]
 1439 0014 8023     		movs	r3, #128
 1440 0016 5B02     		lsls	r3, r3, #9
 1441 0018 1340     		ands	r3, r2
 1442 001a 00D1     		bne	.LCB1338
 1443 001c 8EE0     		b	.L98	@long jump
 1444              	.LCB1338:
 1445              	.LBB4:
 719:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 720:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* check for RTC Parameters used to output RTCCLK */
 721:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 722:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 723:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     FlagStatus       pwrclkchanged = RESET;
 1446              		.loc 1 723 0
 1447 001e 1723     		movs	r3, #23
 1448 0020 FB18     		adds	r3, r7, r3
 1449 0022 0022     		movs	r2, #0
 1450 0024 1A70     		strb	r2, [r3]
 724:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 725:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* As soon as function is called to change RTC clock source, activation of the 
 726:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        power domain is done. */
 727:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Requires to enable write access to Backup Domain of necessary */
 728:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 1451              		.loc 1 728 0
 1452 0026 574B     		ldr	r3, .L109
 1453 0028 DA69     		ldr	r2, [r3, #28]
 1454 002a 8023     		movs	r3, #128
 1455 002c 5B05     		lsls	r3, r3, #21
 1456 002e 1340     		ands	r3, r2
 1457 0030 11D1     		bne	.L99
 1458              	.LBB5:
 729:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 730:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_PWR_CLK_ENABLE();
 1459              		.loc 1 730 0
 1460 0032 544B     		ldr	r3, .L109
 1461 0034 534A     		ldr	r2, .L109
 1462 0036 D269     		ldr	r2, [r2, #28]
 1463 0038 8021     		movs	r1, #128
 1464 003a 4905     		lsls	r1, r1, #21
 1465 003c 0A43     		orrs	r2, r1
 1466 003e DA61     		str	r2, [r3, #28]
 1467 0040 504B     		ldr	r3, .L109
 1468 0042 DA69     		ldr	r2, [r3, #28]
 1469 0044 8023     		movs	r3, #128
 1470 0046 5B05     		lsls	r3, r3, #21
 1471 0048 1340     		ands	r3, r2
 1472 004a BB60     		str	r3, [r7, #8]
 1473 004c BB68     		ldr	r3, [r7, #8]
 1474              	.LBE5:
 731:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       pwrclkchanged = SET;
 1475              		.loc 1 731 0
 1476 004e 1723     		movs	r3, #23
 1477 0050 FB18     		adds	r3, r7, r3
 1478 0052 0122     		movs	r2, #1
 1479 0054 1A70     		strb	r2, [r3]
 1480              	.L99:
 732:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 733:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 734:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 1481              		.loc 1 734 0
 1482 0056 4C4B     		ldr	r3, .L109+4
 1483 0058 1A68     		ldr	r2, [r3]
 1484 005a 8023     		movs	r3, #128
 1485 005c 5B00     		lsls	r3, r3, #1
 1486 005e 1340     		ands	r3, r2
 1487 0060 1AD1     		bne	.L100
 735:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 736:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable write access to Backup domain */
 737:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(PWR->CR, PWR_CR_DBP);
 1488              		.loc 1 737 0
 1489 0062 494B     		ldr	r3, .L109+4
 1490 0064 484A     		ldr	r2, .L109+4
 1491 0066 1268     		ldr	r2, [r2]
 1492 0068 8021     		movs	r1, #128
 1493 006a 4900     		lsls	r1, r1, #1
 1494 006c 0A43     		orrs	r2, r1
 1495 006e 1A60     		str	r2, [r3]
 738:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 739:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait for Backup domain Write protection disable */
 740:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 1496              		.loc 1 740 0
 1497 0070 FFF7FEFF 		bl	HAL_GetTick
 1498 0074 0300     		movs	r3, r0
 1499 0076 3B61     		str	r3, [r7, #16]
 741:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 742:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 1500              		.loc 1 742 0
 1501 0078 08E0     		b	.L101
 1502              	.L103:
 743:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 744:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 1503              		.loc 1 744 0
 1504 007a FFF7FEFF 		bl	HAL_GetTick
 1505 007e 0200     		movs	r2, r0
 1506 0080 3B69     		ldr	r3, [r7, #16]
 1507 0082 D31A     		subs	r3, r2, r3
 1508 0084 642B     		cmp	r3, #100
 1509 0086 01D9     		bls	.L101
 745:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 746:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1510              		.loc 1 746 0
 1511 0088 0323     		movs	r3, #3
 1512 008a 76E0     		b	.L102
 1513              	.L101:
 742:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1514              		.loc 1 742 0
 1515 008c 3E4B     		ldr	r3, .L109+4
 1516 008e 1A68     		ldr	r2, [r3]
 1517 0090 8023     		movs	r3, #128
 1518 0092 5B00     		lsls	r3, r3, #1
 1519 0094 1340     		ands	r3, r2
 1520 0096 F0D0     		beq	.L103
 1521              	.L100:
 747:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 748:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 749:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 750:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 751:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value 
 752:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 1522              		.loc 1 752 0
 1523 0098 3A4B     		ldr	r3, .L109
 1524 009a 1A6A     		ldr	r2, [r3, #32]
 1525 009c C023     		movs	r3, #192
 1526 009e 9B00     		lsls	r3, r3, #2
 1527 00a0 1340     		ands	r3, r2
 1528 00a2 FB60     		str	r3, [r7, #12]
 753:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSE
 1529              		.loc 1 753 0
 1530 00a4 FB68     		ldr	r3, [r7, #12]
 1531 00a6 002B     		cmp	r3, #0
 1532 00a8 34D0     		beq	.L104
 1533              		.loc 1 753 0 is_stmt 0 discriminator 1
 1534 00aa 7B68     		ldr	r3, [r7, #4]
 1535 00ac 5A68     		ldr	r2, [r3, #4]
 1536 00ae C023     		movs	r3, #192
 1537 00b0 9B00     		lsls	r3, r3, #2
 1538 00b2 1A40     		ands	r2, r3
 1539 00b4 FB68     		ldr	r3, [r7, #12]
 1540 00b6 9A42     		cmp	r2, r3
 1541 00b8 2CD0     		beq	.L104
 754:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 755:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Store the content of BDCR register before the reset of Backup Domain */
 756:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 1542              		.loc 1 756 0 is_stmt 1
 1543 00ba 324B     		ldr	r3, .L109
 1544 00bc 1B6A     		ldr	r3, [r3, #32]
 1545 00be 334A     		ldr	r2, .L109+8
 1546 00c0 1340     		ands	r3, r2
 1547 00c2 FB60     		str	r3, [r7, #12]
 757:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* RTC Clock selection can be changed only if the Backup Domain is reset */
 758:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_BACKUPRESET_FORCE();
 1548              		.loc 1 758 0
 1549 00c4 2F4B     		ldr	r3, .L109
 1550 00c6 2F4A     		ldr	r2, .L109
 1551 00c8 126A     		ldr	r2, [r2, #32]
 1552 00ca 8021     		movs	r1, #128
 1553 00cc 4902     		lsls	r1, r1, #9
 1554 00ce 0A43     		orrs	r2, r1
 1555 00d0 1A62     		str	r2, [r3, #32]
 759:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_BACKUPRESET_RELEASE();
 1556              		.loc 1 759 0
 1557 00d2 2C4B     		ldr	r3, .L109
 1558 00d4 2B4A     		ldr	r2, .L109
 1559 00d6 126A     		ldr	r2, [r2, #32]
 1560 00d8 2D49     		ldr	r1, .L109+12
 1561 00da 0A40     		ands	r2, r1
 1562 00dc 1A62     		str	r2, [r3, #32]
 760:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Restore the Content of BDCR register */
 761:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       RCC->BDCR = temp_reg;
 1563              		.loc 1 761 0
 1564 00de 294B     		ldr	r3, .L109
 1565 00e0 FA68     		ldr	r2, [r7, #12]
 1566 00e2 1A62     		str	r2, [r3, #32]
 762:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 763:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait for LSERDY if LSE was enabled */
 764:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 1567              		.loc 1 764 0
 1568 00e4 FB68     		ldr	r3, [r7, #12]
 1569 00e6 0122     		movs	r2, #1
 1570 00e8 1340     		ands	r3, r2
 1571 00ea 13D0     		beq	.L104
 765:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 766:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 767:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 1572              		.loc 1 767 0
 1573 00ec FFF7FEFF 		bl	HAL_GetTick
 1574 00f0 0300     		movs	r3, r0
 1575 00f2 3B61     		str	r3, [r7, #16]
 768:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 769:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till LSE is ready */  
 770:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 1576              		.loc 1 770 0
 1577 00f4 09E0     		b	.L105
 1578              	.L106:
 771:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 772:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 1579              		.loc 1 772 0
 1580 00f6 FFF7FEFF 		bl	HAL_GetTick
 1581 00fa 0200     		movs	r2, r0
 1582 00fc 3B69     		ldr	r3, [r7, #16]
 1583 00fe D31A     		subs	r3, r2, r3
 1584 0100 244A     		ldr	r2, .L109+16
 1585 0102 9342     		cmp	r3, r2
 1586 0104 01D9     		bls	.L105
 773:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 774:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 1587              		.loc 1 774 0
 1588 0106 0323     		movs	r3, #3
 1589 0108 37E0     		b	.L102
 1590              	.L105:
 770:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1591              		.loc 1 770 0
 1592 010a 1E4B     		ldr	r3, .L109
 1593 010c 1B6A     		ldr	r3, [r3, #32]
 1594 010e 0222     		movs	r2, #2
 1595 0110 1340     		ands	r3, r2
 1596 0112 F0D0     		beq	.L106
 1597              	.L104:
 775:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 776:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 777:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 778:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 779:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 1598              		.loc 1 779 0
 1599 0114 1B4A     		ldr	r2, .L109
 1600 0116 1B4B     		ldr	r3, .L109
 1601 0118 1B6A     		ldr	r3, [r3, #32]
 1602 011a 1C49     		ldr	r1, .L109+8
 1603 011c 1940     		ands	r1, r3
 1604 011e 7B68     		ldr	r3, [r7, #4]
 1605 0120 5B68     		ldr	r3, [r3, #4]
 1606 0122 0B43     		orrs	r3, r1
 1607 0124 1362     		str	r3, [r2, #32]
 780:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 781:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Require to disable power clock if necessary */
 782:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(pwrclkchanged == SET)
 1608              		.loc 1 782 0
 1609 0126 1723     		movs	r3, #23
 1610 0128 FB18     		adds	r3, r7, r3
 1611 012a 1B78     		ldrb	r3, [r3]
 1612 012c 012B     		cmp	r3, #1
 1613 012e 05D1     		bne	.L98
 783:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 784:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_PWR_CLK_DISABLE();
 1614              		.loc 1 784 0
 1615 0130 144B     		ldr	r3, .L109
 1616 0132 144A     		ldr	r2, .L109
 1617 0134 D269     		ldr	r2, [r2, #28]
 1618 0136 1849     		ldr	r1, .L109+20
 1619 0138 0A40     		ands	r2, r1
 1620 013a DA61     		str	r2, [r3, #28]
 1621              	.L98:
 1622              	.LBE4:
 785:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 786:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 787:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 788:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------- USART1 Configuration ------------------------*/ 
 789:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 1623              		.loc 1 789 0
 1624 013c 7B68     		ldr	r3, [r7, #4]
 1625 013e 1B68     		ldr	r3, [r3]
 1626 0140 0122     		movs	r2, #1
 1627 0142 1340     		ands	r3, r2
 1628 0144 09D0     		beq	.L107
 790:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 791:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 792:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
 793:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 794:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USART1 clock source */
 795:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 1629              		.loc 1 795 0
 1630 0146 0F4A     		ldr	r2, .L109
 1631 0148 0E4B     		ldr	r3, .L109
 1632 014a 1B6B     		ldr	r3, [r3, #48]
 1633 014c 0321     		movs	r1, #3
 1634 014e 8B43     		bics	r3, r1
 1635 0150 1900     		movs	r1, r3
 1636 0152 7B68     		ldr	r3, [r7, #4]
 1637 0154 9B68     		ldr	r3, [r3, #8]
 1638 0156 0B43     		orrs	r3, r1
 1639 0158 1363     		str	r3, [r2, #48]
 1640              	.L107:
 796:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 797:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 798:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 799:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F091xC) || defined(STM32F098xx)
 800:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- USART2 Configuration --------------------------*/ 
 801:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 802:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 803:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 804:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
 805:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 806:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USART2 clock source */
 807:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 808:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 809:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
 810:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F091xC || STM32F098xx */
 811:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 812:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F091xC) || defined(STM32F098xx)
 813:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- USART3 Configuration --------------------------*/ 
 814:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 815:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 816:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 817:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
 818:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 819:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USART3 clock source */
 820:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 821:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 822:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F091xC || STM32F098xx */  
 823:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 824:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ I2C1 Configuration ------------------------*/ 
 825:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 1641              		.loc 1 825 0
 1642 015a 7B68     		ldr	r3, [r7, #4]
 1643 015c 1B68     		ldr	r3, [r3]
 1644 015e 2022     		movs	r2, #32
 1645 0160 1340     		ands	r3, r2
 1646 0162 09D0     		beq	.L108
 826:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 827:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 828:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
 829:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 830:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the I2C1 clock source */
 831:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 1647              		.loc 1 831 0
 1648 0164 074A     		ldr	r2, .L109
 1649 0166 074B     		ldr	r3, .L109
 1650 0168 1B6B     		ldr	r3, [r3, #48]
 1651 016a 1021     		movs	r1, #16
 1652 016c 8B43     		bics	r3, r1
 1653 016e 1900     		movs	r1, r3
 1654 0170 7B68     		ldr	r3, [r7, #4]
 1655 0172 DB68     		ldr	r3, [r3, #12]
 1656 0174 0B43     		orrs	r3, r1
 1657 0176 1363     		str	r3, [r2, #48]
 1658              	.L108:
 832:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 833:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 834:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) ||
 835:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ USB Configuration ------------------------*/ 
 836:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 837:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 838:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 839:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
 840:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 841:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USB clock source */
 842:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 843:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 844:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB || STM32F070x6 */
 845:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 846:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F042x6) || defined(STM32F048xx)\
 847:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F051x8) || defined(STM32F058xx)\
 848:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 849:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F091xC) || defined(STM32F098xx)
 850:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ CEC clock Configuration -------------------*/ 
 851:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 852:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 853:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 854:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
 855:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 856:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the CEC clock source */
 857:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 858:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 859:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F042x6 || STM32F048xx ||                */
 860:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F051x8 || STM32F058xx ||                */
 861:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F071xB || STM32F072xB || STM32F078xx || */
 862:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F091xC || STM32F098xx */
 863:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 864:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 1659              		.loc 1 864 0
 1660 0178 0023     		movs	r3, #0
 1661              	.L102:
 865:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 1662              		.loc 1 865 0
 1663 017a 1800     		movs	r0, r3
 1664 017c BD46     		mov	sp, r7
 1665 017e 06B0     		add	sp, sp, #24
 1666              		@ sp needed
 1667 0180 80BD     		pop	{r7, pc}
 1668              	.L110:
 1669 0182 C046     		.align	2
 1670              	.L109:
 1671 0184 00100240 		.word	1073876992
 1672 0188 00700040 		.word	1073770496
 1673 018c FFFCFFFF 		.word	-769
 1674 0190 FFFFFEFF 		.word	-65537
 1675 0194 88130000 		.word	5000
 1676 0198 FFFFFFEF 		.word	-268435457
 1677              		.cfi_endproc
 1678              	.LFE41:
 1680              		.section	.text.HAL_GPIO_Init,"ax",%progbits
 1681              		.align	2
 1682              		.global	HAL_GPIO_Init
 1683              		.code	16
 1684              		.thumb_func
 1686              	HAL_GPIO_Init:
 1687              	.LFB42:
 866:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 867:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 868:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 869:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_MODE             (0x00000003U)
 870:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define EXTI_MODE             (0x10000000U)
 871:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_MODE_IT          (0x00010000U)
 872:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_MODE_EVT         (0x00020000U)
 873:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define RISING_EDGE           (0x00100000U)
 874:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define FALLING_EDGE          (0x00200000U)
 875:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_OUTPUT_TYPE      (0x00000010U)
 876:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 877:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_NUMBER           (16U)
 878:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 879:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define __HAL_RCC_GPIOA_CLK_ENABLE()   do { \
 880:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         __IO uint32_t tmpreg; \
 881:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);\
 882:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         /* Delay after an RCC peripheral clock enabling */\
 883:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);\
 884:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         UNUSED(tmpreg); \
 885:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                       } while(0)
 886:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define __HAL_RCC_USART1_CLK_ENABLE()   do { \
 887:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         __IO uint32_t tmpreg; \
 888:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
 889:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         /* Delay after an RCC peripheral clock enabling */\
 890:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
 891:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         UNUSED(tmpreg); \
 892:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                       } while(0)
 893:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 894:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
 895:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Initialize the GPIOx peripheral according to the specified parameters in the GPIO_Init.
 896:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIOx: where x can be (A..F) to select the GPIO peripheral for STM32F0 family
 897:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
 898:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         the configuration information for the specified GPIO peripheral.
 899:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval None
 900:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
 901:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
 902:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** { 
 1688              		.loc 1 902 0
 1689              		.cfi_startproc
 1690              		@ args = 0, pretend = 0, frame = 24
 1691              		@ frame_needed = 1, uses_anonymous_args = 0
 1692 0000 80B5     		push	{r7, lr}
 1693              	.LCFI17:
 1694              		.cfi_def_cfa_offset 8
 1695              		.cfi_offset 7, -8
 1696              		.cfi_offset 14, -4
 1697 0002 86B0     		sub	sp, sp, #24
 1698              	.LCFI18:
 1699              		.cfi_def_cfa_offset 32
 1700 0004 00AF     		add	r7, sp, #0
 1701              	.LCFI19:
 1702              		.cfi_def_cfa_register 7
 1703 0006 7860     		str	r0, [r7, #4]
 1704 0008 3960     		str	r1, [r7]
 903:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t position = 0x00U;
 1705              		.loc 1 903 0
 1706 000a 0023     		movs	r3, #0
 1707 000c 7B61     		str	r3, [r7, #20]
 904:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t iocurrent = 0x00U;
 1708              		.loc 1 904 0
 1709 000e 0023     		movs	r3, #0
 1710 0010 FB60     		str	r3, [r7, #12]
 905:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t temp = 0x00U;
 1711              		.loc 1 905 0
 1712 0012 0023     		movs	r3, #0
 1713 0014 3B61     		str	r3, [r7, #16]
 906:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 907:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 908:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 909:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 910:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 911:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 
 912:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 913:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure the port pins */
 914:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   while (((GPIO_Init->Pin) >> position) != RESET)
 1714              		.loc 1 914 0
 1715 0016 4FE1     		b	.L112
 1716              	.L130:
 915:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 916:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Get current io position */
 917:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     iocurrent = (GPIO_Init->Pin) & (1U << position);
 1717              		.loc 1 917 0
 1718 0018 3B68     		ldr	r3, [r7]
 1719 001a 1B68     		ldr	r3, [r3]
 1720 001c 0121     		movs	r1, #1
 1721 001e 7A69     		ldr	r2, [r7, #20]
 1722 0020 9140     		lsls	r1, r1, r2
 1723 0022 0A00     		movs	r2, r1
 1724 0024 1340     		ands	r3, r2
 1725 0026 FB60     		str	r3, [r7, #12]
 918:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 919:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(iocurrent)
 1726              		.loc 1 919 0
 1727 0028 FB68     		ldr	r3, [r7, #12]
 1728 002a 002B     		cmp	r3, #0
 1729 002c 00D1     		bne	.LCB1603
 1730 002e 40E1     		b	.L113	@long jump
 1731              	.LCB1603:
 920:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 921:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /*--------------------- GPIO Mode Configuration ------------------------*/
 922:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* In case of Alternate function mode selection */
 923:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 1732              		.loc 1 923 0
 1733 0030 3B68     		ldr	r3, [r7]
 1734 0032 5B68     		ldr	r3, [r3, #4]
 1735 0034 022B     		cmp	r3, #2
 1736 0036 03D0     		beq	.L114
 1737              		.loc 1 923 0 is_stmt 0 discriminator 1
 1738 0038 3B68     		ldr	r3, [r7]
 1739 003a 5B68     		ldr	r3, [r3, #4]
 1740 003c 122B     		cmp	r3, #18
 1741 003e 23D1     		bne	.L115
 1742              	.L114:
 924:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 925:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Check the Alternate function parameters */
 926:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 927:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 928:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 929:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure Alternate function mapped with the current IO */ 
 930:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = GPIOx->AFR[position >> 3];
 1743              		.loc 1 930 0 is_stmt 1
 1744 0040 7B69     		ldr	r3, [r7, #20]
 1745 0042 DA08     		lsrs	r2, r3, #3
 1746 0044 7B68     		ldr	r3, [r7, #4]
 1747 0046 0832     		adds	r2, r2, #8
 1748 0048 9200     		lsls	r2, r2, #2
 1749 004a D358     		ldr	r3, [r2, r3]
 1750 004c 3B61     		str	r3, [r7, #16]
 931:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 1751              		.loc 1 931 0
 1752 004e 7B69     		ldr	r3, [r7, #20]
 1753 0050 0722     		movs	r2, #7
 1754 0052 1340     		ands	r3, r2
 1755 0054 9B00     		lsls	r3, r3, #2
 1756 0056 0F22     		movs	r2, #15
 1757 0058 9A40     		lsls	r2, r2, r3
 1758 005a 1300     		movs	r3, r2
 1759 005c DA43     		mvns	r2, r3
 1760 005e 3B69     		ldr	r3, [r7, #16]
 1761 0060 1340     		ands	r3, r2
 1762 0062 3B61     		str	r3, [r7, #16]
 932:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));    
 1763              		.loc 1 932 0
 1764 0064 3B68     		ldr	r3, [r7]
 1765 0066 1A69     		ldr	r2, [r3, #16]
 1766 0068 7B69     		ldr	r3, [r7, #20]
 1767 006a 0721     		movs	r1, #7
 1768 006c 0B40     		ands	r3, r1
 1769 006e 9B00     		lsls	r3, r3, #2
 1770 0070 9A40     		lsls	r2, r2, r3
 1771 0072 1300     		movs	r3, r2
 1772 0074 3A69     		ldr	r2, [r7, #16]
 1773 0076 1343     		orrs	r3, r2
 1774 0078 3B61     		str	r3, [r7, #16]
 933:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         GPIOx->AFR[position >> 3U] = temp;
 1775              		.loc 1 933 0
 1776 007a 7B69     		ldr	r3, [r7, #20]
 1777 007c DA08     		lsrs	r2, r3, #3
 1778 007e 7B68     		ldr	r3, [r7, #4]
 1779 0080 0832     		adds	r2, r2, #8
 1780 0082 9200     		lsls	r2, r2, #2
 1781 0084 3969     		ldr	r1, [r7, #16]
 1782 0086 D150     		str	r1, [r2, r3]
 1783              	.L115:
 934:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 935:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 936:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
 937:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       temp = GPIOx->MODER;
 1784              		.loc 1 937 0
 1785 0088 7B68     		ldr	r3, [r7, #4]
 1786 008a 1B68     		ldr	r3, [r3]
 1787 008c 3B61     		str	r3, [r7, #16]
 938:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 1788              		.loc 1 938 0
 1789 008e 7B69     		ldr	r3, [r7, #20]
 1790 0090 5B00     		lsls	r3, r3, #1
 1791 0092 0322     		movs	r2, #3
 1792 0094 9A40     		lsls	r2, r2, r3
 1793 0096 1300     		movs	r3, r2
 1794 0098 DA43     		mvns	r2, r3
 1795 009a 3B69     		ldr	r3, [r7, #16]
 1796 009c 1340     		ands	r3, r2
 1797 009e 3B61     		str	r3, [r7, #16]
 939:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 1798              		.loc 1 939 0
 1799 00a0 3B68     		ldr	r3, [r7]
 1800 00a2 5B68     		ldr	r3, [r3, #4]
 1801 00a4 0322     		movs	r2, #3
 1802 00a6 1A40     		ands	r2, r3
 1803 00a8 7B69     		ldr	r3, [r7, #20]
 1804 00aa 5B00     		lsls	r3, r3, #1
 1805 00ac 9A40     		lsls	r2, r2, r3
 1806 00ae 1300     		movs	r3, r2
 1807 00b0 3A69     		ldr	r2, [r7, #16]
 1808 00b2 1343     		orrs	r3, r2
 1809 00b4 3B61     		str	r3, [r7, #16]
 940:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       GPIOx->MODER = temp;
 1810              		.loc 1 940 0
 1811 00b6 7B68     		ldr	r3, [r7, #4]
 1812 00b8 3A69     		ldr	r2, [r7, #16]
 1813 00ba 1A60     		str	r2, [r3]
 941:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 942:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* In case of Output or Alternate function mode selection */
 943:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 1814              		.loc 1 943 0
 1815 00bc 3B68     		ldr	r3, [r7]
 1816 00be 5B68     		ldr	r3, [r3, #4]
 1817 00c0 012B     		cmp	r3, #1
 1818 00c2 0BD0     		beq	.L116
 1819              		.loc 1 943 0 is_stmt 0 discriminator 1
 1820 00c4 3B68     		ldr	r3, [r7]
 1821 00c6 5B68     		ldr	r3, [r3, #4]
 1822 00c8 022B     		cmp	r3, #2
 1823 00ca 07D0     		beq	.L116
 944:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 1824              		.loc 1 944 0 is_stmt 1 discriminator 2
 1825 00cc 3B68     		ldr	r3, [r7]
 1826 00ce 5B68     		ldr	r3, [r3, #4]
 943:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 1827              		.loc 1 943 0 discriminator 2
 1828 00d0 112B     		cmp	r3, #17
 1829 00d2 03D0     		beq	.L116
 1830              		.loc 1 944 0
 1831 00d4 3B68     		ldr	r3, [r7]
 1832 00d6 5B68     		ldr	r3, [r3, #4]
 1833 00d8 122B     		cmp	r3, #18
 1834 00da 30D1     		bne	.L117
 1835              	.L116:
 945:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 946:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Check the Speed parameter */
 947:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 948:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure the IO Speed */
 949:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = GPIOx->OSPEEDR; 
 1836              		.loc 1 949 0
 1837 00dc 7B68     		ldr	r3, [r7, #4]
 1838 00de 9B68     		ldr	r3, [r3, #8]
 1839 00e0 3B61     		str	r3, [r7, #16]
 950:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 1840              		.loc 1 950 0
 1841 00e2 7B69     		ldr	r3, [r7, #20]
 1842 00e4 5B00     		lsls	r3, r3, #1
 1843 00e6 0322     		movs	r2, #3
 1844 00e8 9A40     		lsls	r2, r2, r3
 1845 00ea 1300     		movs	r3, r2
 1846 00ec DA43     		mvns	r2, r3
 1847 00ee 3B69     		ldr	r3, [r7, #16]
 1848 00f0 1340     		ands	r3, r2
 1849 00f2 3B61     		str	r3, [r7, #16]
 951:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 1850              		.loc 1 951 0
 1851 00f4 3B68     		ldr	r3, [r7]
 1852 00f6 DA68     		ldr	r2, [r3, #12]
 1853 00f8 7B69     		ldr	r3, [r7, #20]
 1854 00fa 5B00     		lsls	r3, r3, #1
 1855 00fc 9A40     		lsls	r2, r2, r3
 1856 00fe 1300     		movs	r3, r2
 1857 0100 3A69     		ldr	r2, [r7, #16]
 1858 0102 1343     		orrs	r3, r2
 1859 0104 3B61     		str	r3, [r7, #16]
 952:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         GPIOx->OSPEEDR = temp;
 1860              		.loc 1 952 0
 1861 0106 7B68     		ldr	r3, [r7, #4]
 1862 0108 3A69     		ldr	r2, [r7, #16]
 1863 010a 9A60     		str	r2, [r3, #8]
 953:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 954:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure the IO Output Type */
 955:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = GPIOx->OTYPER;
 1864              		.loc 1 955 0
 1865 010c 7B68     		ldr	r3, [r7, #4]
 1866 010e 5B68     		ldr	r3, [r3, #4]
 1867 0110 3B61     		str	r3, [r7, #16]
 956:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 1868              		.loc 1 956 0
 1869 0112 0122     		movs	r2, #1
 1870 0114 7B69     		ldr	r3, [r7, #20]
 1871 0116 9A40     		lsls	r2, r2, r3
 1872 0118 1300     		movs	r3, r2
 1873 011a DA43     		mvns	r2, r3
 1874 011c 3B69     		ldr	r3, [r7, #16]
 1875 011e 1340     		ands	r3, r2
 1876 0120 3B61     		str	r3, [r7, #16]
 957:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 1877              		.loc 1 957 0
 1878 0122 3B68     		ldr	r3, [r7]
 1879 0124 5B68     		ldr	r3, [r3, #4]
 1880 0126 1B09     		lsrs	r3, r3, #4
 1881 0128 0122     		movs	r2, #1
 1882 012a 1A40     		ands	r2, r3
 1883 012c 7B69     		ldr	r3, [r7, #20]
 1884 012e 9A40     		lsls	r2, r2, r3
 1885 0130 1300     		movs	r3, r2
 1886 0132 3A69     		ldr	r2, [r7, #16]
 1887 0134 1343     		orrs	r3, r2
 1888 0136 3B61     		str	r3, [r7, #16]
 958:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         GPIOx->OTYPER = temp;
 1889              		.loc 1 958 0
 1890 0138 7B68     		ldr	r3, [r7, #4]
 1891 013a 3A69     		ldr	r2, [r7, #16]
 1892 013c 5A60     		str	r2, [r3, #4]
 1893              	.L117:
 959:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 960:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 961:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Activate the Pull-up or Pull down resistor for the current IO */
 962:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       temp = GPIOx->PUPDR;
 1894              		.loc 1 962 0
 1895 013e 7B68     		ldr	r3, [r7, #4]
 1896 0140 DB68     		ldr	r3, [r3, #12]
 1897 0142 3B61     		str	r3, [r7, #16]
 963:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 1898              		.loc 1 963 0
 1899 0144 7B69     		ldr	r3, [r7, #20]
 1900 0146 5B00     		lsls	r3, r3, #1
 1901 0148 0322     		movs	r2, #3
 1902 014a 9A40     		lsls	r2, r2, r3
 1903 014c 1300     		movs	r3, r2
 1904 014e DA43     		mvns	r2, r3
 1905 0150 3B69     		ldr	r3, [r7, #16]
 1906 0152 1340     		ands	r3, r2
 1907 0154 3B61     		str	r3, [r7, #16]
 964:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 1908              		.loc 1 964 0
 1909 0156 3B68     		ldr	r3, [r7]
 1910 0158 9A68     		ldr	r2, [r3, #8]
 1911 015a 7B69     		ldr	r3, [r7, #20]
 1912 015c 5B00     		lsls	r3, r3, #1
 1913 015e 9A40     		lsls	r2, r2, r3
 1914 0160 1300     		movs	r3, r2
 1915 0162 3A69     		ldr	r2, [r7, #16]
 1916 0164 1343     		orrs	r3, r2
 1917 0166 3B61     		str	r3, [r7, #16]
 965:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       GPIOx->PUPDR = temp;
 1918              		.loc 1 965 0
 1919 0168 7B68     		ldr	r3, [r7, #4]
 1920 016a 3A69     		ldr	r2, [r7, #16]
 1921 016c DA60     		str	r2, [r3, #12]
 966:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 967:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /*--------------------- EXTI Mode Configuration ------------------------*/
 968:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Configure the External Interrupt or event for the current IO */
 969:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 1922              		.loc 1 969 0
 1923 016e 3B68     		ldr	r3, [r7]
 1924 0170 5A68     		ldr	r2, [r3, #4]
 1925 0172 8023     		movs	r3, #128
 1926 0174 5B05     		lsls	r3, r3, #21
 1927 0176 1340     		ands	r3, r2
 1928 0178 00D1     		bne	.LCB1775
 1929 017a 9AE0     		b	.L113	@long jump
 1930              	.LCB1775:
 1931              	.LBB6:
 970:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 971:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Enable SYSCFG Clock */
 972:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_SYSCFG_CLK_ENABLE();
 1932              		.loc 1 972 0
 1933 017c 544B     		ldr	r3, .L131
 1934 017e 544A     		ldr	r2, .L131
 1935 0180 9269     		ldr	r2, [r2, #24]
 1936 0182 0121     		movs	r1, #1
 1937 0184 0A43     		orrs	r2, r1
 1938 0186 9A61     		str	r2, [r3, #24]
 1939 0188 514B     		ldr	r3, .L131
 1940 018a 9B69     		ldr	r3, [r3, #24]
 1941 018c 0122     		movs	r2, #1
 1942 018e 1340     		ands	r3, r2
 1943 0190 BB60     		str	r3, [r7, #8]
 1944 0192 BB68     		ldr	r3, [r7, #8]
 1945              	.LBE6:
 973:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 974:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = SYSCFG->EXTICR[position >> 2];
 1946              		.loc 1 974 0
 1947 0194 4F4A     		ldr	r2, .L131+4
 1948 0196 7B69     		ldr	r3, [r7, #20]
 1949 0198 9B08     		lsrs	r3, r3, #2
 1950 019a 0233     		adds	r3, r3, #2
 1951 019c 9B00     		lsls	r3, r3, #2
 1952 019e 9B58     		ldr	r3, [r3, r2]
 1953 01a0 3B61     		str	r3, [r7, #16]
 975:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 1954              		.loc 1 975 0
 1955 01a2 7B69     		ldr	r3, [r7, #20]
 1956 01a4 0322     		movs	r2, #3
 1957 01a6 1340     		ands	r3, r2
 1958 01a8 9B00     		lsls	r3, r3, #2
 1959 01aa 0F22     		movs	r2, #15
 1960 01ac 9A40     		lsls	r2, r2, r3
 1961 01ae 1300     		movs	r3, r2
 1962 01b0 DA43     		mvns	r2, r3
 1963 01b2 3B69     		ldr	r3, [r7, #16]
 1964 01b4 1340     		ands	r3, r2
 1965 01b6 3B61     		str	r3, [r7, #16]
 976:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 1966              		.loc 1 976 0
 1967 01b8 7A68     		ldr	r2, [r7, #4]
 1968 01ba 9023     		movs	r3, #144
 1969 01bc DB05     		lsls	r3, r3, #23
 1970 01be 9A42     		cmp	r2, r3
 1971 01c0 13D0     		beq	.L118
 1972              		.loc 1 976 0 is_stmt 0 discriminator 1
 1973 01c2 7B68     		ldr	r3, [r7, #4]
 1974 01c4 444A     		ldr	r2, .L131+8
 1975 01c6 9342     		cmp	r3, r2
 1976 01c8 0DD0     		beq	.L119
 1977              		.loc 1 976 0 discriminator 3
 1978 01ca 7B68     		ldr	r3, [r7, #4]
 1979 01cc 434A     		ldr	r2, .L131+12
 1980 01ce 9342     		cmp	r3, r2
 1981 01d0 07D0     		beq	.L120
 1982              		.loc 1 976 0 discriminator 5
 1983 01d2 7B68     		ldr	r3, [r7, #4]
 1984 01d4 424A     		ldr	r2, .L131+16
 1985 01d6 9342     		cmp	r3, r2
 1986 01d8 01D1     		bne	.L121
 1987              		.loc 1 976 0 discriminator 7
 1988 01da 0323     		movs	r3, #3
 1989 01dc 06E0     		b	.L125
 1990              	.L121:
 1991              		.loc 1 976 0 discriminator 8
 1992 01de 0523     		movs	r3, #5
 1993 01e0 04E0     		b	.L125
 1994              	.L120:
 1995              		.loc 1 976 0 discriminator 6
 1996 01e2 0223     		movs	r3, #2
 1997 01e4 02E0     		b	.L125
 1998              	.L119:
 1999              		.loc 1 976 0 discriminator 4
 2000 01e6 0123     		movs	r3, #1
 2001 01e8 00E0     		b	.L125
 2002              	.L118:
 2003              		.loc 1 976 0 discriminator 2
 2004 01ea 0023     		movs	r3, #0
 2005              	.L125:
 2006              		.loc 1 976 0 discriminator 16
 2007 01ec 7A69     		ldr	r2, [r7, #20]
 2008 01ee 0321     		movs	r1, #3
 2009 01f0 0A40     		ands	r2, r1
 2010 01f2 9200     		lsls	r2, r2, #2
 2011 01f4 9340     		lsls	r3, r3, r2
 2012 01f6 3A69     		ldr	r2, [r7, #16]
 2013 01f8 1343     		orrs	r3, r2
 2014 01fa 3B61     		str	r3, [r7, #16]
 977:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SYSCFG->EXTICR[position >> 2] = temp;
 2015              		.loc 1 977 0 is_stmt 1 discriminator 16
 2016 01fc 3549     		ldr	r1, .L131+4
 2017 01fe 7B69     		ldr	r3, [r7, #20]
 2018 0200 9B08     		lsrs	r3, r3, #2
 2019 0202 0233     		adds	r3, r3, #2
 2020 0204 9B00     		lsls	r3, r3, #2
 2021 0206 3A69     		ldr	r2, [r7, #16]
 2022 0208 5A50     		str	r2, [r3, r1]
 978:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                   
 979:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Clear EXTI line configuration */
 980:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->IMR;
 2023              		.loc 1 980 0 discriminator 16
 2024 020a 364B     		ldr	r3, .L131+20
 2025 020c 1B68     		ldr	r3, [r3]
 2026 020e 3B61     		str	r3, [r7, #16]
 981:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent);
 2027              		.loc 1 981 0 discriminator 16
 2028 0210 FB68     		ldr	r3, [r7, #12]
 2029 0212 DA43     		mvns	r2, r3
 2030 0214 3B69     		ldr	r3, [r7, #16]
 2031 0216 1340     		ands	r3, r2
 2032 0218 3B61     		str	r3, [r7, #16]
 982:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 2033              		.loc 1 982 0 discriminator 16
 2034 021a 3B68     		ldr	r3, [r7]
 2035 021c 5A68     		ldr	r2, [r3, #4]
 2036 021e 8023     		movs	r3, #128
 2037 0220 5B02     		lsls	r3, r3, #9
 2038 0222 1340     		ands	r3, r2
 2039 0224 03D0     		beq	.L126
 983:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 984:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2040              		.loc 1 984 0
 2041 0226 3A69     		ldr	r2, [r7, #16]
 2042 0228 FB68     		ldr	r3, [r7, #12]
 2043 022a 1343     		orrs	r3, r2
 2044 022c 3B61     		str	r3, [r7, #16]
 2045              	.L126:
 985:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 986:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->IMR = temp;
 2046              		.loc 1 986 0
 2047 022e 2D4B     		ldr	r3, .L131+20
 2048 0230 3A69     		ldr	r2, [r7, #16]
 2049 0232 1A60     		str	r2, [r3]
 987:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 988:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->EMR;
 2050              		.loc 1 988 0
 2051 0234 2B4B     		ldr	r3, .L131+20
 2052 0236 5B68     		ldr	r3, [r3, #4]
 2053 0238 3B61     		str	r3, [r7, #16]
 989:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent);      
 2054              		.loc 1 989 0
 2055 023a FB68     		ldr	r3, [r7, #12]
 2056 023c DA43     		mvns	r2, r3
 2057 023e 3B69     		ldr	r3, [r7, #16]
 2058 0240 1340     		ands	r3, r2
 2059 0242 3B61     		str	r3, [r7, #16]
 990:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 2060              		.loc 1 990 0
 2061 0244 3B68     		ldr	r3, [r7]
 2062 0246 5A68     		ldr	r2, [r3, #4]
 2063 0248 8023     		movs	r3, #128
 2064 024a 9B02     		lsls	r3, r3, #10
 2065 024c 1340     		ands	r3, r2
 2066 024e 03D0     		beq	.L127
 991:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         { 
 992:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2067              		.loc 1 992 0
 2068 0250 3A69     		ldr	r2, [r7, #16]
 2069 0252 FB68     		ldr	r3, [r7, #12]
 2070 0254 1343     		orrs	r3, r2
 2071 0256 3B61     		str	r3, [r7, #16]
 2072              	.L127:
 993:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 994:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->EMR = temp;
 2073              		.loc 1 994 0
 2074 0258 224B     		ldr	r3, .L131+20
 2075 025a 3A69     		ldr	r2, [r7, #16]
 2076 025c 5A60     		str	r2, [r3, #4]
 995:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 996:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Clear Rising Falling edge configuration */
 997:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->RTSR;
 2077              		.loc 1 997 0
 2078 025e 214B     		ldr	r3, .L131+20
 2079 0260 9B68     		ldr	r3, [r3, #8]
 2080 0262 3B61     		str	r3, [r7, #16]
 998:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent); 
 2081              		.loc 1 998 0
 2082 0264 FB68     		ldr	r3, [r7, #12]
 2083 0266 DA43     		mvns	r2, r3
 2084 0268 3B69     		ldr	r3, [r7, #16]
 2085 026a 1340     		ands	r3, r2
 2086 026c 3B61     		str	r3, [r7, #16]
 999:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 2087              		.loc 1 999 0
 2088 026e 3B68     		ldr	r3, [r7]
 2089 0270 5A68     		ldr	r2, [r3, #4]
 2090 0272 8023     		movs	r3, #128
 2091 0274 5B03     		lsls	r3, r3, #13
 2092 0276 1340     		ands	r3, r2
 2093 0278 03D0     		beq	.L128
1000:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
1001:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2094              		.loc 1 1001 0
 2095 027a 3A69     		ldr	r2, [r7, #16]
 2096 027c FB68     		ldr	r3, [r7, #12]
 2097 027e 1343     		orrs	r3, r2
 2098 0280 3B61     		str	r3, [r7, #16]
 2099              	.L128:
1002:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
1003:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->RTSR = temp;
 2100              		.loc 1 1003 0
 2101 0282 184B     		ldr	r3, .L131+20
 2102 0284 3A69     		ldr	r2, [r7, #16]
 2103 0286 9A60     		str	r2, [r3, #8]
1004:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1005:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->FTSR;
 2104              		.loc 1 1005 0
 2105 0288 164B     		ldr	r3, .L131+20
 2106 028a DB68     		ldr	r3, [r3, #12]
 2107 028c 3B61     		str	r3, [r7, #16]
1006:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent); 
 2108              		.loc 1 1006 0
 2109 028e FB68     		ldr	r3, [r7, #12]
 2110 0290 DA43     		mvns	r2, r3
 2111 0292 3B69     		ldr	r3, [r7, #16]
 2112 0294 1340     		ands	r3, r2
 2113 0296 3B61     		str	r3, [r7, #16]
1007:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 2114              		.loc 1 1007 0
 2115 0298 3B68     		ldr	r3, [r7]
 2116 029a 5A68     		ldr	r2, [r3, #4]
 2117 029c 8023     		movs	r3, #128
 2118 029e 9B03     		lsls	r3, r3, #14
 2119 02a0 1340     		ands	r3, r2
 2120 02a2 03D0     		beq	.L129
1008:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
1009:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2121              		.loc 1 1009 0
 2122 02a4 3A69     		ldr	r2, [r7, #16]
 2123 02a6 FB68     		ldr	r3, [r7, #12]
 2124 02a8 1343     		orrs	r3, r2
 2125 02aa 3B61     		str	r3, [r7, #16]
 2126              	.L129:
1010:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
1011:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->FTSR = temp;
 2127              		.loc 1 1011 0
 2128 02ac 0D4B     		ldr	r3, .L131+20
 2129 02ae 3A69     		ldr	r2, [r7, #16]
 2130 02b0 DA60     		str	r2, [r3, #12]
 2131              	.L113:
1012:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1013:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1014:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
1015:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     position++;
 2132              		.loc 1 1015 0
 2133 02b2 7B69     		ldr	r3, [r7, #20]
 2134 02b4 0133     		adds	r3, r3, #1
 2135 02b6 7B61     		str	r3, [r7, #20]
 2136              	.L112:
 914:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2137              		.loc 1 914 0
 2138 02b8 3B68     		ldr	r3, [r7]
 2139 02ba 1A68     		ldr	r2, [r3]
 2140 02bc 7B69     		ldr	r3, [r7, #20]
 2141 02be DA40     		lsrs	r2, r2, r3
 2142 02c0 131E     		subs	r3, r2, #0
 2143 02c2 00D0     		beq	.LCB1972
 2144 02c4 A8E6     		b	.L130	@long jump
 2145              	.LCB1972:
1016:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   } 
1017:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2146              		.loc 1 1017 0
 2147 02c6 C046     		nop
 2148 02c8 BD46     		mov	sp, r7
 2149 02ca 06B0     		add	sp, sp, #24
 2150              		@ sp needed
 2151 02cc 80BD     		pop	{r7, pc}
 2152              	.L132:
 2153 02ce C046     		.align	2
 2154              	.L131:
 2155 02d0 00100240 		.word	1073876992
 2156 02d4 00000140 		.word	1073807360
 2157 02d8 00040048 		.word	1207960576
 2158 02dc 00080048 		.word	1207961600
 2159 02e0 000C0048 		.word	1207962624
 2160 02e4 00040140 		.word	1073808384
 2161              		.cfi_endproc
 2162              	.LFE42:
 2164              		.section	.text.HAL_GPIO_WritePin,"ax",%progbits
 2165              		.align	2
 2166              		.global	HAL_GPIO_WritePin
 2167              		.code	16
 2168              		.thumb_func
 2170              	HAL_GPIO_WritePin:
 2171              	.LFB43:
1018:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1019:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1020:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Set or clear the selected data port bit.
1021:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   This function uses GPIOx_BSRR and GPIOx_BRR registers to allow atomic read/modify
1022:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         accesses. In this way, there is no risk of an IRQ occurring between
1023:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         the read and the modify access.
1024:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
1025:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIOx: where x can be (A..H) to select the GPIO peripheral for STM32F0 family
1026:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIO_Pin: specifies the port bit to be written.
1027:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
1028:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  PinState: specifies the value to be written to the selected bit.
1029:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *          This parameter can be one of the GPIO_PinState enum values:
1030:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *            @arg GPIO_PIN_RESET: to clear the port pin
1031:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *            @arg GPIO_PIN_SET: to set the port pin
1032:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval None
1033:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1034:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
1035:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2172              		.loc 1 1035 0
 2173              		.cfi_startproc
 2174              		@ args = 0, pretend = 0, frame = 8
 2175              		@ frame_needed = 1, uses_anonymous_args = 0
 2176 0000 80B5     		push	{r7, lr}
 2177              	.LCFI20:
 2178              		.cfi_def_cfa_offset 8
 2179              		.cfi_offset 7, -8
 2180              		.cfi_offset 14, -4
 2181 0002 82B0     		sub	sp, sp, #8
 2182              	.LCFI21:
 2183              		.cfi_def_cfa_offset 16
 2184 0004 00AF     		add	r7, sp, #0
 2185              	.LCFI22:
 2186              		.cfi_def_cfa_register 7
 2187 0006 7860     		str	r0, [r7, #4]
 2188 0008 0800     		movs	r0, r1
 2189 000a 1100     		movs	r1, r2
 2190 000c BB1C     		adds	r3, r7, #2
 2191 000e 021C     		adds	r2, r0, #0
 2192 0010 1A80     		strh	r2, [r3]
 2193 0012 7B1C     		adds	r3, r7, #1
 2194 0014 0A1C     		adds	r2, r1, #0
 2195 0016 1A70     		strb	r2, [r3]
1036:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
1037:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PIN(GPIO_Pin));
1038:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PIN_ACTION(PinState));
1039:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1040:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (PinState != GPIO_PIN_RESET)
 2196              		.loc 1 1040 0
 2197 0018 7B1C     		adds	r3, r7, #1
 2198 001a 1B78     		ldrb	r3, [r3]
 2199 001c 002B     		cmp	r3, #0
 2200 001e 04D0     		beq	.L134
1041:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1042:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     GPIOx->BSRR = (uint32_t)GPIO_Pin;
 2201              		.loc 1 1042 0
 2202 0020 BB1C     		adds	r3, r7, #2
 2203 0022 1A88     		ldrh	r2, [r3]
 2204 0024 7B68     		ldr	r3, [r7, #4]
 2205 0026 9A61     		str	r2, [r3, #24]
1043:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1044:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1045:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1046:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     GPIOx->BRR = (uint32_t)GPIO_Pin;
1047:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1048:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }										  
 2206              		.loc 1 1048 0
 2207 0028 03E0     		b	.L136
 2208              	.L134:
1046:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 2209              		.loc 1 1046 0
 2210 002a BB1C     		adds	r3, r7, #2
 2211 002c 1A88     		ldrh	r2, [r3]
 2212 002e 7B68     		ldr	r3, [r7, #4]
 2213 0030 9A62     		str	r2, [r3, #40]
 2214              	.L136:
 2215              		.loc 1 1048 0
 2216 0032 C046     		nop
 2217 0034 BD46     		mov	sp, r7
 2218 0036 02B0     		add	sp, sp, #8
 2219              		@ sp needed
 2220 0038 80BD     		pop	{r7, pc}
 2221              		.cfi_endproc
 2222              	.LFE43:
 2224 003a C046     		.section	.text.UART_WaitOnFlagUntilTimeout,"ax",%progbits
 2225              		.align	2
 2226              		.global	UART_WaitOnFlagUntilTimeout
 2227              		.code	16
 2228              		.thumb_func
 2230              	UART_WaitOnFlagUntilTimeout:
 2231              	.LFB44:
1049:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1050:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1051:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Handle UART Communication Timeout.
1052:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  huart UART handle.
1053:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Flag Specifies the UART flag to check
1054:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Status Flag status (SET or RESET)
1055:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Tickstart Tick start value
1056:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Timeout Timeout duration
1057:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1058:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1059:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus 
1060:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2232              		.loc 1 1060 0
 2233              		.cfi_startproc
 2234              		@ args = 4, pretend = 0, frame = 16
 2235              		@ frame_needed = 1, uses_anonymous_args = 0
 2236 0000 80B5     		push	{r7, lr}
 2237              	.LCFI23:
 2238              		.cfi_def_cfa_offset 8
 2239              		.cfi_offset 7, -8
 2240              		.cfi_offset 14, -4
 2241 0002 84B0     		sub	sp, sp, #16
 2242              	.LCFI24:
 2243              		.cfi_def_cfa_offset 24
 2244 0004 00AF     		add	r7, sp, #0
 2245              	.LCFI25:
 2246              		.cfi_def_cfa_register 7
 2247 0006 F860     		str	r0, [r7, #12]
 2248 0008 B960     		str	r1, [r7, #8]
 2249 000a 3B60     		str	r3, [r7]
 2250 000c FB1D     		adds	r3, r7, #7
 2251 000e 1A70     		strb	r2, [r3]
1061:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Wait until flag is set */
1062:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 2252              		.loc 1 1062 0
 2253 0010 2BE0     		b	.L138
 2254              	.L141:
1063:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1064:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check for the Timeout */
1065:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(Timeout != HAL_MAX_DELAY)
 2255              		.loc 1 1065 0
 2256 0012 BB69     		ldr	r3, [r7, #24]
 2257 0014 0133     		adds	r3, r3, #1
 2258 0016 28D0     		beq	.L138
1066:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1067:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 2259              		.loc 1 1067 0
 2260 0018 BB69     		ldr	r3, [r7, #24]
 2261 001a 002B     		cmp	r3, #0
 2262 001c 07D0     		beq	.L139
 2263              		.loc 1 1067 0 is_stmt 0 discriminator 1
 2264 001e FFF7FEFF 		bl	HAL_GetTick
 2265 0022 0200     		movs	r2, r0
 2266 0024 3B68     		ldr	r3, [r7]
 2267 0026 D21A     		subs	r2, r2, r3
 2268 0028 BB69     		ldr	r3, [r7, #24]
 2269 002a 9A42     		cmp	r2, r3
 2270 002c 1DD9     		bls	.L138
 2271              	.L139:
1068:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1069:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for t
1070:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 2272              		.loc 1 1070 0 is_stmt 1
 2273 002e FB68     		ldr	r3, [r7, #12]
 2274 0030 1B68     		ldr	r3, [r3]
 2275 0032 FA68     		ldr	r2, [r7, #12]
 2276 0034 1268     		ldr	r2, [r2]
 2277 0036 1268     		ldr	r2, [r2]
 2278 0038 1649     		ldr	r1, .L142
 2279 003a 0A40     		ands	r2, r1
 2280 003c 1A60     		str	r2, [r3]
1071:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 2281              		.loc 1 1071 0
 2282 003e FB68     		ldr	r3, [r7, #12]
 2283 0040 1B68     		ldr	r3, [r3]
 2284 0042 FA68     		ldr	r2, [r7, #12]
 2285 0044 1268     		ldr	r2, [r2]
 2286 0046 9268     		ldr	r2, [r2, #8]
 2287 0048 0121     		movs	r1, #1
 2288 004a 8A43     		bics	r2, r1
 2289 004c 9A60     		str	r2, [r3, #8]
1072:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1073:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->gState  = HAL_UART_STATE_READY;
 2290              		.loc 1 1073 0
 2291 004e FB68     		ldr	r3, [r7, #12]
 2292 0050 6922     		movs	r2, #105
 2293 0052 2021     		movs	r1, #32
 2294 0054 9954     		strb	r1, [r3, r2]
1074:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->RxState = HAL_UART_STATE_READY;
 2295              		.loc 1 1074 0
 2296 0056 FB68     		ldr	r3, [r7, #12]
 2297 0058 6A22     		movs	r2, #106
 2298 005a 2021     		movs	r1, #32
 2299 005c 9954     		strb	r1, [r3, r2]
1075:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1076:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Process Unlocked */
1077:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_UNLOCK(huart);
 2300              		.loc 1 1077 0
 2301 005e FB68     		ldr	r3, [r7, #12]
 2302 0060 6822     		movs	r2, #104
 2303 0062 0021     		movs	r1, #0
 2304 0064 9954     		strb	r1, [r3, r2]
1078:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
 2305              		.loc 1 1078 0
 2306 0066 0323     		movs	r3, #3
 2307 0068 0FE0     		b	.L140
 2308              	.L138:
1062:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2309              		.loc 1 1062 0
 2310 006a FB68     		ldr	r3, [r7, #12]
 2311 006c 1B68     		ldr	r3, [r3]
 2312 006e DB69     		ldr	r3, [r3, #28]
 2313 0070 BA68     		ldr	r2, [r7, #8]
 2314 0072 1A40     		ands	r2, r3
 2315 0074 BB68     		ldr	r3, [r7, #8]
 2316 0076 D31A     		subs	r3, r2, r3
 2317 0078 5A42     		rsbs	r2, r3, #0
 2318 007a 5341     		adcs	r3, r3, r2
 2319 007c DBB2     		uxtb	r3, r3
 2320 007e 1A00     		movs	r2, r3
 2321 0080 FB1D     		adds	r3, r7, #7
 2322 0082 1B78     		ldrb	r3, [r3]
 2323 0084 9A42     		cmp	r2, r3
 2324 0086 C4D0     		beq	.L141
1079:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1080:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1081:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1082:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 2325              		.loc 1 1082 0
 2326 0088 0023     		movs	r3, #0
 2327              	.L140:
1083:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2328              		.loc 1 1083 0
 2329 008a 1800     		movs	r0, r3
 2330 008c BD46     		mov	sp, r7
 2331 008e 04B0     		add	sp, sp, #16
 2332              		@ sp needed
 2333 0090 80BD     		pop	{r7, pc}
 2334              	.L143:
 2335 0092 C046     		.align	2
 2336              	.L142:
 2337 0094 5FFEFFFF 		.word	-417
 2338              		.cfi_endproc
 2339              	.LFE44:
 2341              		.section	.text.UART_CheckIdleState,"ax",%progbits
 2342              		.align	2
 2343              		.global	UART_CheckIdleState
 2344              		.code	16
 2345              		.thumb_func
 2347              	UART_CheckIdleState:
 2348              	.LFB45:
1084:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1085:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1086:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Check the UART Idle State.
1087:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart UART handle.
1088:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1089:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1090:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
1091:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2349              		.loc 1 1091 0
 2350              		.cfi_startproc
 2351              		@ args = 0, pretend = 0, frame = 8
 2352              		@ frame_needed = 1, uses_anonymous_args = 0
 2353 0000 80B5     		push	{r7, lr}
 2354              	.LCFI26:
 2355              		.cfi_def_cfa_offset 8
 2356              		.cfi_offset 7, -8
 2357              		.cfi_offset 14, -4
 2358 0002 82B0     		sub	sp, sp, #8
 2359              	.LCFI27:
 2360              		.cfi_def_cfa_offset 16
 2361 0004 00AF     		add	r7, sp, #0
 2362              	.LCFI28:
 2363              		.cfi_def_cfa_register 7
 2364 0006 7860     		str	r0, [r7, #4]
1092:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&
1093:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
1094:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F0
1095:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1096:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Initialize the UART ErrorCode */
1097:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->ErrorCode = HAL_UART_ERROR_NONE;
 2365              		.loc 1 1097 0
 2366 0008 7B68     		ldr	r3, [r7, #4]
 2367 000a 0022     		movs	r2, #0
 2368 000c DA66     		str	r2, [r3, #108]
1098:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1099:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&
1100:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Init tickstart for timeout managment*/
1101:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   tickstart = HAL_GetTick();
1102:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1103:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* TEACK and REACK bits in ISR are checked only when available (not available on all F0 devices).
1104:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****      Bits are defined for some specific devices, and are available only for UART instances supporti
1105:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1106:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
1107:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1108:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if the Transmitter is enabled */
1109:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
1110:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1111:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait until TEACK flag is set */
1112:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VAL
1113:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1114:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Timeout occurred */
1115:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
1116:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1117:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1118:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1119:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if the Receiver is enabled */
1120:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
1121:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1122:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait until REACK flag is set */
1123:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VAL
1124:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1125:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Timeout occurred */
1126:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
1127:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1128:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1129:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1130:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F0
1131:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1132:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Initialize the UART State */
1133:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->gState  = HAL_UART_STATE_READY;
 2369              		.loc 1 1133 0
 2370 000e 7B68     		ldr	r3, [r7, #4]
 2371 0010 6922     		movs	r2, #105
 2372 0012 2021     		movs	r1, #32
 2373 0014 9954     		strb	r1, [r3, r2]
1134:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->RxState = HAL_UART_STATE_READY;
 2374              		.loc 1 1134 0
 2375 0016 7B68     		ldr	r3, [r7, #4]
 2376 0018 6A22     		movs	r2, #106
 2377 001a 2021     		movs	r1, #32
 2378 001c 9954     		strb	r1, [r3, r2]
1135:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1136:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Process Unlocked */
1137:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   __HAL_UNLOCK(huart);
 2379              		.loc 1 1137 0
 2380 001e 7B68     		ldr	r3, [r7, #4]
 2381 0020 6822     		movs	r2, #104
 2382 0022 0021     		movs	r1, #0
 2383 0024 9954     		strb	r1, [r3, r2]
1138:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1139:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 2384              		.loc 1 1139 0
 2385 0026 0023     		movs	r3, #0
1140:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2386              		.loc 1 1140 0
 2387 0028 1800     		movs	r0, r3
 2388 002a BD46     		mov	sp, r7
 2389 002c 02B0     		add	sp, sp, #8
 2390              		@ sp needed
 2391 002e 80BD     		pop	{r7, pc}
 2392              		.cfi_endproc
 2393              	.LFE45:
 2395              		.global	__aeabi_uidiv
 2396              		.section	.text.UART_SetConfig,"ax",%progbits
 2397              		.align	2
 2398              		.global	UART_SetConfig
 2399              		.code	16
 2400              		.thumb_func
 2402              	UART_SetConfig:
 2403              	.LFB46:
1141:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1142:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
1143:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2404              		.loc 1 1143 0
 2405              		.cfi_startproc
 2406              		@ args = 0, pretend = 0, frame = 24
 2407              		@ frame_needed = 1, uses_anonymous_args = 0
 2408 0000 90B5     		push	{r4, r7, lr}
 2409              	.LCFI29:
 2410              		.cfi_def_cfa_offset 12
 2411              		.cfi_offset 4, -12
 2412              		.cfi_offset 7, -8
 2413              		.cfi_offset 14, -4
 2414 0002 87B0     		sub	sp, sp, #28
 2415              	.LCFI30:
 2416              		.cfi_def_cfa_offset 40
 2417 0004 00AF     		add	r7, sp, #0
 2418              	.LCFI31:
 2419              		.cfi_def_cfa_register 7
 2420 0006 7860     		str	r0, [r7, #4]
1144:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tmpreg                     = 0x00000000U;
 2421              		.loc 1 1144 0
 2422 0008 0023     		movs	r3, #0
 2423 000a FB60     		str	r3, [r7, #12]
1145:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 2424              		.loc 1 1145 0
 2425 000c 1723     		movs	r3, #23
 2426 000e FB18     		adds	r3, r7, r3
 2427 0010 1022     		movs	r2, #16
 2428 0012 1A70     		strb	r2, [r3]
1146:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t brrtemp                    = 0x0000U;
 2429              		.loc 1 1146 0
 2430 0014 0A23     		movs	r3, #10
 2431 0016 FB18     		adds	r3, r7, r3
 2432 0018 0022     		movs	r2, #0
 2433 001a 1A80     		strh	r2, [r3]
1147:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t usartdiv                   = 0x0000U;
 2434              		.loc 1 1147 0
 2435 001c 1423     		movs	r3, #20
 2436 001e FB18     		adds	r3, r7, r3
 2437 0020 0022     		movs	r2, #0
 2438 0022 1A80     		strh	r2, [r3]
1148:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 2439              		.loc 1 1148 0
 2440 0024 1323     		movs	r3, #19
 2441 0026 FB18     		adds	r3, r7, r3
 2442 0028 0022     		movs	r2, #0
 2443 002a 1A70     		strb	r2, [r3]
1149:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1150:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
1151:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
1152:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
1153:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
1154:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_PARITY(huart->Init.Parity));
1155:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_MODE(huart->Init.Mode));
1156:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
1157:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
1158:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
1159:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1160:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1161:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART CR1 Configuration -----------------------*/
1162:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
1163:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  the UART Word Length, Parity, Mode and oversampling:
1164:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set the M bits according to huart->Init.WordLength value
1165:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set PCE and PS bits according to huart->Init.Parity value
1166:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set TE and RE bits according to huart->Init.Mode value
1167:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set OVER8 bit according to huart->Init.OverSampling value */
1168:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.O
 2444              		.loc 1 1168 0
 2445 002c 7B68     		ldr	r3, [r7, #4]
 2446 002e 9A68     		ldr	r2, [r3, #8]
 2447 0030 7B68     		ldr	r3, [r7, #4]
 2448 0032 1B69     		ldr	r3, [r3, #16]
 2449 0034 1A43     		orrs	r2, r3
 2450 0036 7B68     		ldr	r3, [r7, #4]
 2451 0038 5B69     		ldr	r3, [r3, #20]
 2452 003a 1A43     		orrs	r2, r3
 2453 003c 7B68     		ldr	r3, [r7, #4]
 2454 003e DB69     		ldr	r3, [r3, #28]
 2455 0040 1343     		orrs	r3, r2
 2456 0042 FB60     		str	r3, [r7, #12]
1169:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 2457              		.loc 1 1169 0
 2458 0044 7B68     		ldr	r3, [r7, #4]
 2459 0046 1B68     		ldr	r3, [r3]
 2460 0048 7A68     		ldr	r2, [r7, #4]
 2461 004a 1268     		ldr	r2, [r2]
 2462 004c 1268     		ldr	r2, [r2]
 2463 004e 9549     		ldr	r1, .L171
 2464 0050 1140     		ands	r1, r2
 2465 0052 FA68     		ldr	r2, [r7, #12]
 2466 0054 0A43     		orrs	r2, r1
 2467 0056 1A60     		str	r2, [r3]
1170:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1171:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART CR2 Configuration -----------------------*/
1172:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure the UART Stop Bits: Set STOP[13:12] bits according
1173:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    * to huart->Init.StopBits value */
1174:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 2468              		.loc 1 1174 0
 2469 0058 7B68     		ldr	r3, [r7, #4]
 2470 005a 1B68     		ldr	r3, [r3]
 2471 005c 7A68     		ldr	r2, [r7, #4]
 2472 005e 1268     		ldr	r2, [r2]
 2473 0060 5268     		ldr	r2, [r2, #4]
 2474 0062 9149     		ldr	r1, .L171+4
 2475 0064 1140     		ands	r1, r2
 2476 0066 7A68     		ldr	r2, [r7, #4]
 2477 0068 D268     		ldr	r2, [r2, #12]
 2478 006a 0A43     		orrs	r2, r1
 2479 006c 5A60     		str	r2, [r3, #4]
1175:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1176:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART CR3 Configuration -----------------------*/
1177:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure
1178:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    * - UART HardWare Flow Control: set CTSE and RTSE bits according
1179:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *   to huart->Init.HwFlowCtl value
1180:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    * - one-bit sampling method versus three samples' majority rule according
1181:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *   to huart->Init.OneBitSampling */
1182:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 2480              		.loc 1 1182 0
 2481 006e 7B68     		ldr	r3, [r7, #4]
 2482 0070 9A69     		ldr	r2, [r3, #24]
 2483 0072 7B68     		ldr	r3, [r7, #4]
 2484 0074 1B6A     		ldr	r3, [r3, #32]
 2485 0076 1343     		orrs	r3, r2
 2486 0078 FB60     		str	r3, [r7, #12]
1183:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 2487              		.loc 1 1183 0
 2488 007a 7B68     		ldr	r3, [r7, #4]
 2489 007c 1B68     		ldr	r3, [r3]
 2490 007e 7A68     		ldr	r2, [r7, #4]
 2491 0080 1268     		ldr	r2, [r2]
 2492 0082 9268     		ldr	r2, [r2, #8]
 2493 0084 8949     		ldr	r1, .L171+8
 2494 0086 1140     		ands	r1, r2
 2495 0088 FA68     		ldr	r2, [r7, #12]
 2496 008a 0A43     		orrs	r2, r1
 2497 008c 9A60     		str	r2, [r3, #8]
1184:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1185:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART BRR Configuration -----------------------*/
1186:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   UART_GETCLOCKSOURCE(huart, clocksource);
 2498              		.loc 1 1186 0
 2499 008e 884B     		ldr	r3, .L171+12
 2500 0090 1B6B     		ldr	r3, [r3, #48]
 2501 0092 0322     		movs	r2, #3
 2502 0094 1340     		ands	r3, r2
 2503 0096 012B     		cmp	r3, #1
 2504 0098 0FD0     		beq	.L148
 2505 009a 04D3     		bcc	.L149
 2506 009c 022B     		cmp	r3, #2
 2507 009e 11D0     		beq	.L150
 2508 00a0 032B     		cmp	r3, #3
 2509 00a2 05D0     		beq	.L151
 2510 00a4 13E0     		b	.L169
 2511              	.L149:
 2512              		.loc 1 1186 0 is_stmt 0 discriminator 2
 2513 00a6 1723     		movs	r3, #23
 2514 00a8 FB18     		adds	r3, r7, r3
 2515 00aa 0022     		movs	r2, #0
 2516 00ac 1A70     		strb	r2, [r3]
 2517 00ae 12E0     		b	.L170
 2518              	.L151:
 2519              		.loc 1 1186 0 discriminator 5
 2520 00b0 1723     		movs	r3, #23
 2521 00b2 FB18     		adds	r3, r7, r3
 2522 00b4 0222     		movs	r2, #2
 2523 00b6 1A70     		strb	r2, [r3]
 2524 00b8 0DE0     		b	.L170
 2525              	.L148:
 2526              		.loc 1 1186 0 discriminator 3
 2527 00ba 1723     		movs	r3, #23
 2528 00bc FB18     		adds	r3, r7, r3
 2529 00be 0422     		movs	r2, #4
 2530 00c0 1A70     		strb	r2, [r3]
 2531 00c2 08E0     		b	.L170
 2532              	.L150:
 2533              		.loc 1 1186 0 discriminator 4
 2534 00c4 1723     		movs	r3, #23
 2535 00c6 FB18     		adds	r3, r7, r3
 2536 00c8 0822     		movs	r2, #8
 2537 00ca 1A70     		strb	r2, [r3]
 2538 00cc 03E0     		b	.L170
 2539              	.L169:
 2540              		.loc 1 1186 0 discriminator 1
 2541 00ce 1723     		movs	r3, #23
 2542 00d0 FB18     		adds	r3, r7, r3
 2543 00d2 1022     		movs	r2, #16
 2544 00d4 1A70     		strb	r2, [r3]
 2545              	.L170:
 2546              		.loc 1 1186 0
 2547 00d6 C046     		nop
1187:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
1188:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check UART Over Sampling to set Baud Rate Register */
1189:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 2548              		.loc 1 1189 0 is_stmt 1
 2549 00d8 7B68     		ldr	r3, [r7, #4]
 2550 00da DA69     		ldr	r2, [r3, #28]
 2551 00dc 8023     		movs	r3, #128
 2552 00de 1B02     		lsls	r3, r3, #8
 2553 00e0 9A42     		cmp	r2, r3
 2554 00e2 00D0     		beq	.LCB2341
 2555 00e4 7BE0     		b	.L153	@long jump
 2556              	.LCB2341:
1190:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1191:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     switch (clocksource)
 2557              		.loc 1 1191 0
 2558 00e6 1723     		movs	r3, #23
 2559 00e8 FB18     		adds	r3, r7, r3
 2560 00ea 1B78     		ldrb	r3, [r3]
 2561 00ec 022B     		cmp	r3, #2
 2562 00ee 1CD0     		beq	.L155
 2563 00f0 02DC     		bgt	.L156
 2564 00f2 002B     		cmp	r3, #0
 2565 00f4 05D0     		beq	.L157
 2566 00f6 4FE0     		b	.L154
 2567              	.L156:
 2568 00f8 042B     		cmp	r3, #4
 2569 00fa 27D0     		beq	.L158
 2570 00fc 082B     		cmp	r3, #8
 2571 00fe 39D0     		beq	.L159
 2572 0100 4AE0     		b	.L154
 2573              	.L157:
1192:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1193:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_PCLK1:
1194:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 2574              		.loc 1 1194 0
 2575 0102 FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 2576 0106 0300     		movs	r3, r0
 2577 0108 5A00     		lsls	r2, r3, #1
 2578 010a 7B68     		ldr	r3, [r7, #4]
 2579 010c 5B68     		ldr	r3, [r3, #4]
 2580 010e 5B08     		lsrs	r3, r3, #1
 2581 0110 D218     		adds	r2, r2, r3
 2582 0112 7B68     		ldr	r3, [r7, #4]
 2583 0114 5B68     		ldr	r3, [r3, #4]
 2584 0116 1900     		movs	r1, r3
 2585 0118 1000     		movs	r0, r2
 2586 011a FFF7FEFF 		bl	__aeabi_uidiv
 2587 011e 0300     		movs	r3, r0
 2588 0120 1A00     		movs	r2, r3
 2589 0122 1423     		movs	r3, #20
 2590 0124 FB18     		adds	r3, r7, r3
 2591 0126 1A80     		strh	r2, [r3]
1195:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2592              		.loc 1 1195 0
 2593 0128 3BE0     		b	.L160
 2594              	.L155:
1196:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_HSI:
1197:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 2595              		.loc 1 1197 0
 2596 012a 7B68     		ldr	r3, [r7, #4]
 2597 012c 5B68     		ldr	r3, [r3, #4]
 2598 012e 5B08     		lsrs	r3, r3, #1
 2599 0130 604A     		ldr	r2, .L171+16
 2600 0132 9A18     		adds	r2, r3, r2
 2601 0134 7B68     		ldr	r3, [r7, #4]
 2602 0136 5B68     		ldr	r3, [r3, #4]
 2603 0138 1900     		movs	r1, r3
 2604 013a 1000     		movs	r0, r2
 2605 013c FFF7FEFF 		bl	__aeabi_uidiv
 2606 0140 0300     		movs	r3, r0
 2607 0142 1A00     		movs	r2, r3
 2608 0144 1423     		movs	r3, #20
 2609 0146 FB18     		adds	r3, r7, r3
 2610 0148 1A80     		strh	r2, [r3]
1198:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2611              		.loc 1 1198 0
 2612 014a 2AE0     		b	.L160
 2613              	.L158:
1199:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_SYSCLK:
1200:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 2614              		.loc 1 1200 0
 2615 014c FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 2616 0150 0300     		movs	r3, r0
 2617 0152 5A00     		lsls	r2, r3, #1
 2618 0154 7B68     		ldr	r3, [r7, #4]
 2619 0156 5B68     		ldr	r3, [r3, #4]
 2620 0158 5B08     		lsrs	r3, r3, #1
 2621 015a D218     		adds	r2, r2, r3
 2622 015c 7B68     		ldr	r3, [r7, #4]
 2623 015e 5B68     		ldr	r3, [r3, #4]
 2624 0160 1900     		movs	r1, r3
 2625 0162 1000     		movs	r0, r2
 2626 0164 FFF7FEFF 		bl	__aeabi_uidiv
 2627 0168 0300     		movs	r3, r0
 2628 016a 1A00     		movs	r2, r3
 2629 016c 1423     		movs	r3, #20
 2630 016e FB18     		adds	r3, r7, r3
 2631 0170 1A80     		strh	r2, [r3]
1201:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2632              		.loc 1 1201 0
 2633 0172 16E0     		b	.L160
 2634              	.L159:
1202:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_LSE:
1203:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 2635              		.loc 1 1203 0
 2636 0174 7B68     		ldr	r3, [r7, #4]
 2637 0176 5B68     		ldr	r3, [r3, #4]
 2638 0178 5B08     		lsrs	r3, r3, #1
 2639 017a 8022     		movs	r2, #128
 2640 017c 5202     		lsls	r2, r2, #9
 2641 017e 9A18     		adds	r2, r3, r2
 2642 0180 7B68     		ldr	r3, [r7, #4]
 2643 0182 5B68     		ldr	r3, [r3, #4]
 2644 0184 1900     		movs	r1, r3
 2645 0186 1000     		movs	r0, r2
 2646 0188 FFF7FEFF 		bl	__aeabi_uidiv
 2647 018c 0300     		movs	r3, r0
 2648 018e 1A00     		movs	r2, r3
 2649 0190 1423     		movs	r3, #20
 2650 0192 FB18     		adds	r3, r7, r3
 2651 0194 1A80     		strh	r2, [r3]
1204:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2652              		.loc 1 1204 0
 2653 0196 04E0     		b	.L160
 2654              	.L154:
1205:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_UNDEFINED:
1206:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       default:
1207:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         ret = HAL_ERROR;
 2655              		.loc 1 1207 0
 2656 0198 1323     		movs	r3, #19
 2657 019a FB18     		adds	r3, r7, r3
 2658 019c 0122     		movs	r2, #1
 2659 019e 1A70     		strb	r2, [r3]
1208:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2660              		.loc 1 1208 0
 2661 01a0 C046     		nop
 2662              	.L160:
1209:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1210:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1211:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     brrtemp = usartdiv & 0xFFF0U;
 2663              		.loc 1 1211 0
 2664 01a2 0A23     		movs	r3, #10
 2665 01a4 FB18     		adds	r3, r7, r3
 2666 01a6 1422     		movs	r2, #20
 2667 01a8 BA18     		adds	r2, r7, r2
 2668 01aa 1288     		ldrh	r2, [r2]
 2669 01ac 0F21     		movs	r1, #15
 2670 01ae 8A43     		bics	r2, r1
 2671 01b0 1A80     		strh	r2, [r3]
1212:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 2672              		.loc 1 1212 0
 2673 01b2 1423     		movs	r3, #20
 2674 01b4 FB18     		adds	r3, r7, r3
 2675 01b6 1B88     		ldrh	r3, [r3]
 2676 01b8 5B10     		asrs	r3, r3, #1
 2677 01ba 9BB2     		uxth	r3, r3
 2678 01bc 0722     		movs	r2, #7
 2679 01be 1340     		ands	r3, r2
 2680 01c0 99B2     		uxth	r1, r3
 2681 01c2 0A23     		movs	r3, #10
 2682 01c4 FB18     		adds	r3, r7, r3
 2683 01c6 0A22     		movs	r2, #10
 2684 01c8 BA18     		adds	r2, r7, r2
 2685 01ca 1288     		ldrh	r2, [r2]
 2686 01cc 0A43     		orrs	r2, r1
 2687 01ce 1A80     		strh	r2, [r3]
1213:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->Instance->BRR = brrtemp;
 2688              		.loc 1 1213 0
 2689 01d0 7B68     		ldr	r3, [r7, #4]
 2690 01d2 1B68     		ldr	r3, [r3]
 2691 01d4 0A22     		movs	r2, #10
 2692 01d6 BA18     		adds	r2, r7, r2
 2693 01d8 1288     		ldrh	r2, [r2]
 2694 01da DA60     		str	r2, [r3, #12]
 2695 01dc 5BE0     		b	.L161
 2696              	.L153:
1214:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1215:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1216:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1217:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     switch (clocksource)
 2697              		.loc 1 1217 0
 2698 01de 1723     		movs	r3, #23
 2699 01e0 FB18     		adds	r3, r7, r3
 2700 01e2 1B78     		ldrb	r3, [r3]
 2701 01e4 022B     		cmp	r3, #2
 2702 01e6 1BD0     		beq	.L163
 2703 01e8 02DC     		bgt	.L164
 2704 01ea 002B     		cmp	r3, #0
 2705 01ec 05D0     		beq	.L165
 2706 01ee 4DE0     		b	.L162
 2707              	.L164:
 2708 01f0 042B     		cmp	r3, #4
 2709 01f2 26D0     		beq	.L166
 2710 01f4 082B     		cmp	r3, #8
 2711 01f6 37D0     		beq	.L167
 2712 01f8 48E0     		b	.L162
 2713              	.L165:
1218:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1219:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_PCLK1:
1220:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.B
 2714              		.loc 1 1220 0
 2715 01fa 7B68     		ldr	r3, [r7, #4]
 2716 01fc 1C68     		ldr	r4, [r3]
 2717 01fe FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 2718 0202 0200     		movs	r2, r0
 2719 0204 7B68     		ldr	r3, [r7, #4]
 2720 0206 5B68     		ldr	r3, [r3, #4]
 2721 0208 5B08     		lsrs	r3, r3, #1
 2722 020a D218     		adds	r2, r2, r3
 2723 020c 7B68     		ldr	r3, [r7, #4]
 2724 020e 5B68     		ldr	r3, [r3, #4]
 2725 0210 1900     		movs	r1, r3
 2726 0212 1000     		movs	r0, r2
 2727 0214 FFF7FEFF 		bl	__aeabi_uidiv
 2728 0218 0300     		movs	r3, r0
 2729 021a 9BB2     		uxth	r3, r3
 2730 021c E360     		str	r3, [r4, #12]
1221:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2731              		.loc 1 1221 0
 2732 021e 3AE0     		b	.L161
 2733              	.L163:
1222:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_HSI:
1223:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 2734              		.loc 1 1223 0
 2735 0220 7B68     		ldr	r3, [r7, #4]
 2736 0222 1C68     		ldr	r4, [r3]
 2737 0224 7B68     		ldr	r3, [r7, #4]
 2738 0226 5B68     		ldr	r3, [r3, #4]
 2739 0228 5B08     		lsrs	r3, r3, #1
 2740 022a 234A     		ldr	r2, .L171+20
 2741 022c 9A18     		adds	r2, r3, r2
 2742 022e 7B68     		ldr	r3, [r7, #4]
 2743 0230 5B68     		ldr	r3, [r3, #4]
 2744 0232 1900     		movs	r1, r3
 2745 0234 1000     		movs	r0, r2
 2746 0236 FFF7FEFF 		bl	__aeabi_uidiv
 2747 023a 0300     		movs	r3, r0
 2748 023c 9BB2     		uxth	r3, r3
 2749 023e E360     		str	r3, [r4, #12]
1224:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2750              		.loc 1 1224 0
 2751 0240 29E0     		b	.L161
 2752              	.L166:
1225:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_SYSCLK:
1226:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Ini
 2753              		.loc 1 1226 0
 2754 0242 7B68     		ldr	r3, [r7, #4]
 2755 0244 1C68     		ldr	r4, [r3]
 2756 0246 FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 2757 024a 0200     		movs	r2, r0
 2758 024c 7B68     		ldr	r3, [r7, #4]
 2759 024e 5B68     		ldr	r3, [r3, #4]
 2760 0250 5B08     		lsrs	r3, r3, #1
 2761 0252 D218     		adds	r2, r2, r3
 2762 0254 7B68     		ldr	r3, [r7, #4]
 2763 0256 5B68     		ldr	r3, [r3, #4]
 2764 0258 1900     		movs	r1, r3
 2765 025a 1000     		movs	r0, r2
 2766 025c FFF7FEFF 		bl	__aeabi_uidiv
 2767 0260 0300     		movs	r3, r0
 2768 0262 9BB2     		uxth	r3, r3
 2769 0264 E360     		str	r3, [r4, #12]
1227:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2770              		.loc 1 1227 0
 2771 0266 16E0     		b	.L161
 2772              	.L167:
1228:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_LSE:
1229:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 2773              		.loc 1 1229 0
 2774 0268 7B68     		ldr	r3, [r7, #4]
 2775 026a 1C68     		ldr	r4, [r3]
 2776 026c 7B68     		ldr	r3, [r7, #4]
 2777 026e 5B68     		ldr	r3, [r3, #4]
 2778 0270 5B08     		lsrs	r3, r3, #1
 2779 0272 8022     		movs	r2, #128
 2780 0274 1202     		lsls	r2, r2, #8
 2781 0276 9A18     		adds	r2, r3, r2
 2782 0278 7B68     		ldr	r3, [r7, #4]
 2783 027a 5B68     		ldr	r3, [r3, #4]
 2784 027c 1900     		movs	r1, r3
 2785 027e 1000     		movs	r0, r2
 2786 0280 FFF7FEFF 		bl	__aeabi_uidiv
 2787 0284 0300     		movs	r3, r0
 2788 0286 9BB2     		uxth	r3, r3
 2789 0288 E360     		str	r3, [r4, #12]
1230:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2790              		.loc 1 1230 0
 2791 028a 04E0     		b	.L161
 2792              	.L162:
1231:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_UNDEFINED:
1232:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       default:
1233:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         ret = HAL_ERROR;
 2793              		.loc 1 1233 0
 2794 028c 1323     		movs	r3, #19
 2795 028e FB18     		adds	r3, r7, r3
 2796 0290 0122     		movs	r2, #1
 2797 0292 1A70     		strb	r2, [r3]
1234:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2798              		.loc 1 1234 0
 2799 0294 C046     		nop
 2800              	.L161:
1235:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1236:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1237:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1238:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return ret;
 2801              		.loc 1 1238 0
 2802 0296 1323     		movs	r3, #19
 2803 0298 FB18     		adds	r3, r7, r3
 2804 029a 1B78     		ldrb	r3, [r3]
1239:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1240:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2805              		.loc 1 1240 0
 2806 029c 1800     		movs	r0, r3
 2807 029e BD46     		mov	sp, r7
 2808 02a0 07B0     		add	sp, sp, #28
 2809              		@ sp needed
 2810 02a2 90BD     		pop	{r4, r7, pc}
 2811              	.L172:
 2812              		.align	2
 2813              	.L171:
 2814 02a4 F369FFFF 		.word	-38413
 2815 02a8 FFCFFFFF 		.word	-12289
 2816 02ac FFF4FFFF 		.word	-2817
 2817 02b0 00100240 		.word	1073876992
 2818 02b4 0048E801 		.word	32000000
 2819 02b8 0024F400 		.word	16000000
 2820              		.cfi_endproc
 2821              	.LFE46:
 2823              		.section	.text.HAL_UART_Init,"ax",%progbits
 2824              		.align	2
 2825              		.global	HAL_UART_Init
 2826              		.code	16
 2827              		.thumb_func
 2829              	HAL_UART_Init:
 2830              	.LFB47:
1241:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1242:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1243:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Initialize the UART mode according to the specified
1244:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *        parameters in the UART_InitTypeDef and initialize the associated handle.
1245:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart: UART handle.
1246:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1247:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1248:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
1249:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2831              		.loc 1 1249 0
 2832              		.cfi_startproc
 2833              		@ args = 0, pretend = 0, frame = 8
 2834              		@ frame_needed = 1, uses_anonymous_args = 0
 2835 0000 80B5     		push	{r7, lr}
 2836              	.LCFI32:
 2837              		.cfi_def_cfa_offset 8
 2838              		.cfi_offset 7, -8
 2839              		.cfi_offset 14, -4
 2840 0002 82B0     		sub	sp, sp, #8
 2841              	.LCFI33:
 2842              		.cfi_def_cfa_offset 16
 2843 0004 00AF     		add	r7, sp, #0
 2844              	.LCFI34:
 2845              		.cfi_def_cfa_register 7
 2846 0006 7860     		str	r0, [r7, #4]
1250:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the UART handle allocation */
1251:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart == NULL)
 2847              		.loc 1 1251 0
 2848 0008 7B68     		ldr	r3, [r7, #4]
 2849 000a 002B     		cmp	r3, #0
 2850 000c 01D1     		bne	.L174
1252:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1253:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_ERROR;
 2851              		.loc 1 1253 0
 2852 000e 0123     		movs	r3, #1
 2853 0010 3BE0     		b	.L175
 2854              	.L174:
1254:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1255:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1256:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
1257:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1258:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
1259:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
1260:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1261:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1262:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1263:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
1264:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_UART_INSTANCE(huart->Instance));
1265:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1266:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1267:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->gState == HAL_UART_STATE_RESET)
 2855              		.loc 1 1267 0
 2856 0012 7B68     		ldr	r3, [r7, #4]
 2857 0014 6922     		movs	r2, #105
 2858 0016 9B5C     		ldrb	r3, [r3, r2]
 2859 0018 DBB2     		uxtb	r3, r3
 2860 001a 002B     		cmp	r3, #0
 2861 001c 03D1     		bne	.L176
1268:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1269:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Allocate lock resource and initialize it */
1270:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->Lock = HAL_UNLOCKED;
 2862              		.loc 1 1270 0
 2863 001e 7B68     		ldr	r3, [r7, #4]
 2864 0020 6822     		movs	r2, #104
 2865 0022 0021     		movs	r1, #0
 2866 0024 9954     		strb	r1, [r3, r2]
 2867              	.L176:
1271:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1272:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Init the low level hardware : GPIO, CLOCK */
1273:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     //HAL_UART_MspInit(huart);
1274:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1275:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1276:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->gState = HAL_UART_STATE_BUSY;
 2868              		.loc 1 1276 0
 2869 0026 7B68     		ldr	r3, [r7, #4]
 2870 0028 6922     		movs	r2, #105
 2871 002a 2421     		movs	r1, #36
 2872 002c 9954     		strb	r1, [r3, r2]
1277:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1278:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Disable the Peripheral */
1279:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   __HAL_UART_DISABLE(huart);
 2873              		.loc 1 1279 0
 2874 002e 7B68     		ldr	r3, [r7, #4]
 2875 0030 1B68     		ldr	r3, [r3]
 2876 0032 7A68     		ldr	r2, [r7, #4]
 2877 0034 1268     		ldr	r2, [r2]
 2878 0036 1268     		ldr	r2, [r2]
 2879 0038 0121     		movs	r1, #1
 2880 003a 8A43     		bics	r2, r1
 2881 003c 1A60     		str	r2, [r3]
1280:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1281:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Set the UART Communication parameters */
1282:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (UART_SetConfig(huart) == HAL_ERROR)
 2882              		.loc 1 1282 0
 2883 003e 7B68     		ldr	r3, [r7, #4]
 2884 0040 1800     		movs	r0, r3
 2885 0042 FFF7FEFF 		bl	UART_SetConfig
 2886 0046 0300     		movs	r3, r0
 2887 0048 012B     		cmp	r3, #1
 2888 004a 01D1     		bne	.L177
1283:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1284:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_ERROR;
 2889              		.loc 1 1284 0
 2890 004c 0123     		movs	r3, #1
 2891 004e 1CE0     		b	.L175
 2892              	.L177:
1285:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1286:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1287:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
1288:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1289:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     //UART_AdvFeatureConfig(huart);
1290:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1291:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1292:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* In asynchronous mode, the following bits must be kept cleared:
1293:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
1294:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported)  bits in the USART_CR3 
1295:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR2_LINEN)
1296:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
1297:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1298:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 2893              		.loc 1 1298 0
 2894 0050 7B68     		ldr	r3, [r7, #4]
 2895 0052 1B68     		ldr	r3, [r3]
 2896 0054 7A68     		ldr	r2, [r7, #4]
 2897 0056 1268     		ldr	r2, [r2]
 2898 0058 5268     		ldr	r2, [r2, #4]
 2899 005a 0E49     		ldr	r1, .L178
 2900 005c 0A40     		ands	r2, r1
 2901 005e 5A60     		str	r2, [r3, #4]
1299:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1300:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR3_SCEN)
1301:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR3_IREN)
1302:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
1303:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1304:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
1305:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1306:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1307:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR3_IREN)
1308:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN));
1309:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1310:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 2902              		.loc 1 1310 0
 2903 0060 7B68     		ldr	r3, [r7, #4]
 2904 0062 1B68     		ldr	r3, [r3]
 2905 0064 7A68     		ldr	r2, [r7, #4]
 2906 0066 1268     		ldr	r2, [r2]
 2907 0068 9268     		ldr	r2, [r2, #8]
 2908 006a 0821     		movs	r1, #8
 2909 006c 8A43     		bics	r2, r1
 2910 006e 9A60     		str	r2, [r3, #8]
1311:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1312:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1313:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1314:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Enable the Peripheral */
1315:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   __HAL_UART_ENABLE(huart);
 2911              		.loc 1 1315 0
 2912 0070 7B68     		ldr	r3, [r7, #4]
 2913 0072 1B68     		ldr	r3, [r3]
 2914 0074 7A68     		ldr	r2, [r7, #4]
 2915 0076 1268     		ldr	r2, [r2]
 2916 0078 1268     		ldr	r2, [r2]
 2917 007a 0121     		movs	r1, #1
 2918 007c 0A43     		orrs	r2, r1
 2919 007e 1A60     		str	r2, [r3]
1316:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1317:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
1318:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return (UART_CheckIdleState(huart));
 2920              		.loc 1 1318 0
 2921 0080 7B68     		ldr	r3, [r7, #4]
 2922 0082 1800     		movs	r0, r3
 2923 0084 FFF7FEFF 		bl	UART_CheckIdleState
 2924 0088 0300     		movs	r3, r0
 2925              	.L175:
1319:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2926              		.loc 1 1319 0
 2927 008a 1800     		movs	r0, r3
 2928 008c BD46     		mov	sp, r7
 2929 008e 02B0     		add	sp, sp, #8
 2930              		@ sp needed
 2931 0090 80BD     		pop	{r7, pc}
 2932              	.L179:
 2933 0092 C046     		.align	2
 2934              	.L178:
 2935 0094 FFF7FFFF 		.word	-2049
 2936              		.cfi_endproc
 2937              	.LFE47:
 2939              		.section	.text.HAL_UART_Receive,"ax",%progbits
 2940              		.align	2
 2941              		.global	HAL_UART_Receive
 2942              		.code	16
 2943              		.thumb_func
 2945              	HAL_UART_Receive:
 2946              	.LFB48:
1320:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1321:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1322:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Receive an amount of data in blocking mode.
1323:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart: UART handle.
1324:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param pData: pointer to data buffer.
1325:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Size: amount of data to be received.
1326:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Timeout: Timeout duration.
1327:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-
1328:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         address of user data buffer for storing data to be received, should be aligned on a hal
1329:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         (as received data will be handled using u16 pointer cast). Depending on compilation cha
1330:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         use of specific alignment compilation directives or pragmas might be required to ensure
1331:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1332:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1333:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32
1334:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2947              		.loc 1 1334 0
 2948              		.cfi_startproc
 2949              		@ args = 0, pretend = 0, frame = 32
 2950              		@ frame_needed = 1, uses_anonymous_args = 0
 2951 0000 80B5     		push	{r7, lr}
 2952              	.LCFI35:
 2953              		.cfi_def_cfa_offset 8
 2954              		.cfi_offset 7, -8
 2955              		.cfi_offset 14, -4
 2956 0002 8AB0     		sub	sp, sp, #40
 2957              	.LCFI36:
 2958              		.cfi_def_cfa_offset 48
 2959 0004 02AF     		add	r7, sp, #8
 2960              	.LCFI37:
 2961              		.cfi_def_cfa 7, 40
 2962 0006 F860     		str	r0, [r7, #12]
 2963 0008 B960     		str	r1, [r7, #8]
 2964 000a 3B60     		str	r3, [r7]
 2965 000c BB1D     		adds	r3, r7, #6
 2966 000e 1A80     		strh	r2, [r3]
1335:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t* tmp;
1336:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t uhMask;
1337:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0;
 2967              		.loc 1 1337 0
 2968 0010 0023     		movs	r3, #0
 2969 0012 FB61     		str	r3, [r7, #28]
1338:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1339:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check that a Rx process is not already ongoing */
1340:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->RxState == HAL_UART_STATE_READY)
 2970              		.loc 1 1340 0
 2971 0014 FB68     		ldr	r3, [r7, #12]
 2972 0016 6A22     		movs	r2, #106
 2973 0018 9B5C     		ldrb	r3, [r3, r2]
 2974 001a DBB2     		uxtb	r3, r3
 2975 001c 202B     		cmp	r3, #32
 2976 001e 00D0     		beq	.LCB2750
 2977 0020 B4E0     		b	.L181	@long jump
 2978              	.LCB2750:
1341:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1342:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((pData == NULL ) || (Size == 0U))
 2979              		.loc 1 1342 0
 2980 0022 BB68     		ldr	r3, [r7, #8]
 2981 0024 002B     		cmp	r3, #0
 2982 0026 03D0     		beq	.L182
 2983              		.loc 1 1342 0 is_stmt 0 discriminator 1
 2984 0028 BB1D     		adds	r3, r7, #6
 2985 002a 1B88     		ldrh	r3, [r3]
 2986 002c 002B     		cmp	r3, #0
 2987 002e 01D1     		bne	.L183
 2988              	.L182:
1343:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1344:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return  HAL_ERROR;
 2989              		.loc 1 1344 0 is_stmt 1
 2990 0030 0123     		movs	r3, #1
 2991 0032 ACE0     		b	.L184
 2992              	.L183:
1345:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1346:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1347:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
1348:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        should be aligned on a u16 frontier, as data to be received from RDR will be 
1349:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        handled through a u16 cast. */
1350:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 2993              		.loc 1 1350 0
 2994 0034 FB68     		ldr	r3, [r7, #12]
 2995 0036 9A68     		ldr	r2, [r3, #8]
 2996 0038 8023     		movs	r3, #128
 2997 003a 5B01     		lsls	r3, r3, #5
 2998 003c 9A42     		cmp	r2, r3
 2999 003e 09D1     		bne	.L185
 3000              		.loc 1 1350 0 is_stmt 0 discriminator 1
 3001 0040 FB68     		ldr	r3, [r7, #12]
 3002 0042 1B69     		ldr	r3, [r3, #16]
 3003 0044 002B     		cmp	r3, #0
 3004 0046 05D1     		bne	.L185
1351:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1352:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((((uint32_t)pData)&1U) != 0U)
 3005              		.loc 1 1352 0 is_stmt 1
 3006 0048 BB68     		ldr	r3, [r7, #8]
 3007 004a 0122     		movs	r2, #1
 3008 004c 1340     		ands	r3, r2
 3009 004e 01D0     		beq	.L185
1353:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1354:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return  HAL_ERROR;
 3010              		.loc 1 1354 0
 3011 0050 0123     		movs	r3, #1
 3012 0052 9CE0     		b	.L184
 3013              	.L185:
1355:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1356:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1357:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1358:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Locked */
1359:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_LOCK(huart);
 3014              		.loc 1 1359 0
 3015 0054 FB68     		ldr	r3, [r7, #12]
 3016 0056 6822     		movs	r2, #104
 3017 0058 9B5C     		ldrb	r3, [r3, r2]
 3018 005a 012B     		cmp	r3, #1
 3019 005c 01D1     		bne	.L186
 3020              		.loc 1 1359 0 is_stmt 0 discriminator 1
 3021 005e 0223     		movs	r3, #2
 3022 0060 95E0     		b	.L184
 3023              	.L186:
 3024              		.loc 1 1359 0 discriminator 2
 3025 0062 FB68     		ldr	r3, [r7, #12]
 3026 0064 6822     		movs	r2, #104
 3027 0066 0121     		movs	r1, #1
 3028 0068 9954     		strb	r1, [r3, r2]
1360:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1361:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 3029              		.loc 1 1361 0 is_stmt 1 discriminator 2
 3030 006a FB68     		ldr	r3, [r7, #12]
 3031 006c 0022     		movs	r2, #0
 3032 006e DA66     		str	r2, [r3, #108]
1362:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
 3033              		.loc 1 1362 0 discriminator 2
 3034 0070 FB68     		ldr	r3, [r7, #12]
 3035 0072 6A22     		movs	r2, #106
 3036 0074 2221     		movs	r1, #34
 3037 0076 9954     		strb	r1, [r3, r2]
1363:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1364:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Init tickstart for timeout managment*/
1365:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     tickstart = HAL_GetTick();
 3038              		.loc 1 1365 0 discriminator 2
 3039 0078 FFF7FEFF 		bl	HAL_GetTick
 3040 007c 0300     		movs	r3, r0
 3041 007e FB61     		str	r3, [r7, #28]
1366:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1367:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxXferSize = Size;
 3042              		.loc 1 1367 0 discriminator 2
 3043 0080 FB68     		ldr	r3, [r7, #12]
 3044 0082 BA1D     		adds	r2, r7, #6
 3045 0084 5821     		movs	r1, #88
 3046 0086 1288     		ldrh	r2, [r2]
 3047 0088 5A52     		strh	r2, [r3, r1]
1368:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxXferCount = Size;
 3048              		.loc 1 1368 0 discriminator 2
 3049 008a FB68     		ldr	r3, [r7, #12]
 3050 008c BA1D     		adds	r2, r7, #6
 3051 008e 5A21     		movs	r1, #90
 3052 0090 1288     		ldrh	r2, [r2]
 3053 0092 5A52     		strh	r2, [r3, r1]
1369:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1370:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Computation of UART mask to apply to RDR register */
1371:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     UART_MASK_COMPUTATION(huart);
 3054              		.loc 1 1371 0 discriminator 2
 3055 0094 FB68     		ldr	r3, [r7, #12]
 3056 0096 9A68     		ldr	r2, [r3, #8]
 3057 0098 8023     		movs	r3, #128
 3058 009a 5B01     		lsls	r3, r3, #5
 3059 009c 9A42     		cmp	r2, r3
 3060 009e 0DD1     		bne	.L187
 3061              		.loc 1 1371 0 is_stmt 0 discriminator 1
 3062 00a0 FB68     		ldr	r3, [r7, #12]
 3063 00a2 1B69     		ldr	r3, [r3, #16]
 3064 00a4 002B     		cmp	r3, #0
 3065 00a6 04D1     		bne	.L188
 3066              		.loc 1 1371 0 discriminator 3
 3067 00a8 FB68     		ldr	r3, [r7, #12]
 3068 00aa 5C22     		movs	r2, #92
 3069 00ac 3A49     		ldr	r1, .L196
 3070 00ae 9952     		strh	r1, [r3, r2]
 3071 00b0 15E0     		b	.L190
 3072              	.L188:
 3073              		.loc 1 1371 0 discriminator 4
 3074 00b2 FB68     		ldr	r3, [r7, #12]
 3075 00b4 5C22     		movs	r2, #92
 3076 00b6 FF21     		movs	r1, #255
 3077 00b8 9952     		strh	r1, [r3, r2]
 3078 00ba 10E0     		b	.L190
 3079              	.L187:
 3080              		.loc 1 1371 0 discriminator 2
 3081 00bc FB68     		ldr	r3, [r7, #12]
 3082 00be 9B68     		ldr	r3, [r3, #8]
 3083 00c0 002B     		cmp	r3, #0
 3084 00c2 0CD1     		bne	.L190
 3085              		.loc 1 1371 0 discriminator 5
 3086 00c4 FB68     		ldr	r3, [r7, #12]
 3087 00c6 1B69     		ldr	r3, [r3, #16]
 3088 00c8 002B     		cmp	r3, #0
 3089 00ca 04D1     		bne	.L191
 3090              		.loc 1 1371 0 discriminator 6
 3091 00cc FB68     		ldr	r3, [r7, #12]
 3092 00ce 5C22     		movs	r2, #92
 3093 00d0 FF21     		movs	r1, #255
 3094 00d2 9952     		strh	r1, [r3, r2]
 3095 00d4 03E0     		b	.L190
 3096              	.L191:
 3097              		.loc 1 1371 0 discriminator 7
 3098 00d6 FB68     		ldr	r3, [r7, #12]
 3099 00d8 5C22     		movs	r2, #92
 3100 00da 7F21     		movs	r1, #127
 3101 00dc 9952     		strh	r1, [r3, r2]
 3102              	.L190:
1372:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     uhMask = huart->Mask;
 3103              		.loc 1 1372 0 is_stmt 1
 3104 00de 1A23     		movs	r3, #26
 3105 00e0 FB18     		adds	r3, r7, r3
 3106 00e2 FA68     		ldr	r2, [r7, #12]
 3107 00e4 5C21     		movs	r1, #92
 3108 00e6 525A     		ldrh	r2, [r2, r1]
 3109 00e8 1A80     		strh	r2, [r3]
1373:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1374:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* as long as data have to be received */
1375:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     while(huart->RxXferCount > 0U)
 3110              		.loc 1 1375 0
 3111 00ea 3FE0     		b	.L192
 3112              	.L195:
1376:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1377:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       huart->RxXferCount--;
 3113              		.loc 1 1377 0
 3114 00ec FB68     		ldr	r3, [r7, #12]
 3115 00ee 5A22     		movs	r2, #90
 3116 00f0 9B5A     		ldrh	r3, [r3, r2]
 3117 00f2 9BB2     		uxth	r3, r3
 3118 00f4 013B     		subs	r3, r3, #1
 3119 00f6 99B2     		uxth	r1, r3
 3120 00f8 FB68     		ldr	r3, [r7, #12]
 3121 00fa 5A22     		movs	r2, #90
 3122 00fc 9952     		strh	r1, [r3, r2]
1378:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 3123              		.loc 1 1378 0
 3124 00fe FA69     		ldr	r2, [r7, #28]
 3125 0100 F868     		ldr	r0, [r7, #12]
 3126 0102 3B68     		ldr	r3, [r7]
 3127 0104 0093     		str	r3, [sp]
 3128 0106 1300     		movs	r3, r2
 3129 0108 0022     		movs	r2, #0
 3130 010a 2021     		movs	r1, #32
 3131 010c FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 3132 0110 031E     		subs	r3, r0, #0
 3133 0112 01D0     		beq	.L193
1379:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1380:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
 3134              		.loc 1 1380 0
 3135 0114 0323     		movs	r3, #3
 3136 0116 3AE0     		b	.L184
 3137              	.L193:
1381:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1382:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE
 3138              		.loc 1 1382 0
 3139 0118 FB68     		ldr	r3, [r7, #12]
 3140 011a 9A68     		ldr	r2, [r3, #8]
 3141 011c 8023     		movs	r3, #128
 3142 011e 5B01     		lsls	r3, r3, #5
 3143 0120 9A42     		cmp	r2, r3
 3144 0122 14D1     		bne	.L194
 3145              		.loc 1 1382 0 is_stmt 0 discriminator 1
 3146 0124 FB68     		ldr	r3, [r7, #12]
 3147 0126 1B69     		ldr	r3, [r3, #16]
 3148 0128 002B     		cmp	r3, #0
 3149 012a 10D1     		bne	.L194
1383:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1384:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tmp = (uint16_t*) pData ;
 3150              		.loc 1 1384 0 is_stmt 1
 3151 012c BB68     		ldr	r3, [r7, #8]
 3152 012e 7B61     		str	r3, [r7, #20]
1385:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 3153              		.loc 1 1385 0
 3154 0130 FB68     		ldr	r3, [r7, #12]
 3155 0132 1B68     		ldr	r3, [r3]
 3156 0134 9B8C     		ldrh	r3, [r3, #36]
 3157 0136 9BB2     		uxth	r3, r3
 3158 0138 1A22     		movs	r2, #26
 3159 013a BA18     		adds	r2, r7, r2
 3160 013c 1288     		ldrh	r2, [r2]
 3161 013e 1340     		ands	r3, r2
 3162 0140 9AB2     		uxth	r2, r3
 3163 0142 7B69     		ldr	r3, [r7, #20]
 3164 0144 1A80     		strh	r2, [r3]
1386:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         pData +=2U;
 3165              		.loc 1 1386 0
 3166 0146 BB68     		ldr	r3, [r7, #8]
 3167 0148 0233     		adds	r3, r3, #2
 3168 014a BB60     		str	r3, [r7, #8]
 3169 014c 0EE0     		b	.L192
 3170              	.L194:
1387:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1388:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
1389:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1390:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 3171              		.loc 1 1390 0
 3172 014e BB68     		ldr	r3, [r7, #8]
 3173 0150 5A1C     		adds	r2, r3, #1
 3174 0152 BA60     		str	r2, [r7, #8]
 3175 0154 FA68     		ldr	r2, [r7, #12]
 3176 0156 1268     		ldr	r2, [r2]
 3177 0158 928C     		ldrh	r2, [r2, #36]
 3178 015a 92B2     		uxth	r2, r2
 3179 015c D2B2     		uxtb	r2, r2
 3180 015e 1A21     		movs	r1, #26
 3181 0160 7918     		adds	r1, r7, r1
 3182 0162 0988     		ldrh	r1, [r1]
 3183 0164 C9B2     		uxtb	r1, r1
 3184 0166 0A40     		ands	r2, r1
 3185 0168 D2B2     		uxtb	r2, r2
 3186 016a 1A70     		strb	r2, [r3]
 3187              	.L192:
1375:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 3188              		.loc 1 1375 0
 3189 016c FB68     		ldr	r3, [r7, #12]
 3190 016e 5A22     		movs	r2, #90
 3191 0170 9B5A     		ldrh	r3, [r3, r2]
 3192 0172 9BB2     		uxth	r3, r3
 3193 0174 002B     		cmp	r3, #0
 3194 0176 B9D1     		bne	.L195
1391:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1392:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1393:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1394:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* At end of Rx process, restore huart->RxState to Ready */
1395:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxState = HAL_UART_STATE_READY;
 3195              		.loc 1 1395 0
 3196 0178 FB68     		ldr	r3, [r7, #12]
 3197 017a 6A22     		movs	r2, #106
 3198 017c 2021     		movs	r1, #32
 3199 017e 9954     		strb	r1, [r3, r2]
1396:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1397:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Unlocked */
1398:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_UNLOCK(huart);
 3200              		.loc 1 1398 0
 3201 0180 FB68     		ldr	r3, [r7, #12]
 3202 0182 6822     		movs	r2, #104
 3203 0184 0021     		movs	r1, #0
 3204 0186 9954     		strb	r1, [r3, r2]
1399:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1400:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_OK;
 3205              		.loc 1 1400 0
 3206 0188 0023     		movs	r3, #0
 3207 018a 00E0     		b	.L184
 3208              	.L181:
1401:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1402:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1403:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1404:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_BUSY;
 3209              		.loc 1 1404 0
 3210 018c 0223     		movs	r3, #2
 3211              	.L184:
1405:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1406:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 3212              		.loc 1 1406 0
 3213 018e 1800     		movs	r0, r3
 3214 0190 BD46     		mov	sp, r7
 3215 0192 08B0     		add	sp, sp, #32
 3216              		@ sp needed
 3217 0194 80BD     		pop	{r7, pc}
 3218              	.L197:
 3219 0196 C046     		.align	2
 3220              	.L196:
 3221 0198 FF010000 		.word	511
 3222              		.cfi_endproc
 3223              	.LFE48:
 3225              		.section	.text.HAL_UART_Transmit,"ax",%progbits
 3226              		.align	2
 3227              		.global	HAL_UART_Transmit
 3228              		.code	16
 3229              		.thumb_func
 3231              	HAL_UART_Transmit:
 3232              	.LFB49:
1407:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1408:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1409:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Send an amount of data in blocking mode.
1410:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart: UART handle.
1411:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param pData: Pointer to data buffer.
1412:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Size: Amount of data to be sent.
1413:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Timeout: Timeout duration.
1414:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-
1415:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         address of user data buffer containing data to be sent, should be aligned on a half wor
1416:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         (as sent data will be handled using u16 pointer cast). Depending on compilation chain,
1417:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         use of specific alignment compilation directives or pragmas might be required to ensure
1418:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1419:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1420:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint3
1421:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 3233              		.loc 1 1421 0
 3234              		.cfi_startproc
 3235              		@ args = 0, pretend = 0, frame = 24
 3236              		@ frame_needed = 1, uses_anonymous_args = 0
 3237 0000 80B5     		push	{r7, lr}
 3238              	.LCFI38:
 3239              		.cfi_def_cfa_offset 8
 3240              		.cfi_offset 7, -8
 3241              		.cfi_offset 14, -4
 3242 0002 88B0     		sub	sp, sp, #32
 3243              	.LCFI39:
 3244              		.cfi_def_cfa_offset 40
 3245 0004 02AF     		add	r7, sp, #8
 3246              	.LCFI40:
 3247              		.cfi_def_cfa 7, 32
 3248 0006 F860     		str	r0, [r7, #12]
 3249 0008 B960     		str	r1, [r7, #8]
 3250 000a 3B60     		str	r3, [r7]
 3251 000c BB1D     		adds	r3, r7, #6
 3252 000e 1A80     		strh	r2, [r3]
1422:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t* tmp;
1423:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
 3253              		.loc 1 1423 0
 3254 0010 0023     		movs	r3, #0
 3255 0012 7B61     		str	r3, [r7, #20]
1424:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1425:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check that a Tx process is not already ongoing */
1426:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->gState == HAL_UART_STATE_READY)
 3256              		.loc 1 1426 0
 3257 0014 FB68     		ldr	r3, [r7, #12]
 3258 0016 6922     		movs	r2, #105
 3259 0018 9B5C     		ldrb	r3, [r3, r2]
 3260 001a DBB2     		uxtb	r3, r3
 3261 001c 202B     		cmp	r3, #32
 3262 001e 00D0     		beq	.LCB3014
 3263 0020 8CE0     		b	.L199	@long jump
 3264              	.LCB3014:
1427:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1428:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((pData == NULL ) || (Size == 0U))
 3265              		.loc 1 1428 0
 3266 0022 BB68     		ldr	r3, [r7, #8]
 3267 0024 002B     		cmp	r3, #0
 3268 0026 03D0     		beq	.L200
 3269              		.loc 1 1428 0 is_stmt 0 discriminator 1
 3270 0028 BB1D     		adds	r3, r7, #6
 3271 002a 1B88     		ldrh	r3, [r3]
 3272 002c 002B     		cmp	r3, #0
 3273 002e 01D1     		bne	.L201
 3274              	.L200:
1429:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1430:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return  HAL_ERROR;
 3275              		.loc 1 1430 0 is_stmt 1
 3276 0030 0123     		movs	r3, #1
 3277 0032 84E0     		b	.L202
 3278              	.L201:
1431:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1432:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1433:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
1434:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        should be aligned on a u16 frontier, as data to be filled into TDR will be 
1435:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        handled through a u16 cast. */
1436:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 3279              		.loc 1 1436 0
 3280 0034 FB68     		ldr	r3, [r7, #12]
 3281 0036 9A68     		ldr	r2, [r3, #8]
 3282 0038 8023     		movs	r3, #128
 3283 003a 5B01     		lsls	r3, r3, #5
 3284 003c 9A42     		cmp	r2, r3
 3285 003e 09D1     		bne	.L203
 3286              		.loc 1 1436 0 is_stmt 0 discriminator 1
 3287 0040 FB68     		ldr	r3, [r7, #12]
 3288 0042 1B69     		ldr	r3, [r3, #16]
 3289 0044 002B     		cmp	r3, #0
 3290 0046 05D1     		bne	.L203
1437:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1438:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((((uint32_t)pData)&1U) != 0U)
 3291              		.loc 1 1438 0 is_stmt 1
 3292 0048 BB68     		ldr	r3, [r7, #8]
 3293 004a 0122     		movs	r2, #1
 3294 004c 1340     		ands	r3, r2
 3295 004e 01D0     		beq	.L203
1439:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1440:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return  HAL_ERROR;
 3296              		.loc 1 1440 0
 3297 0050 0123     		movs	r3, #1
 3298 0052 74E0     		b	.L202
 3299              	.L203:
1441:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1442:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1443:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1444:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Locked */
1445:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_LOCK(huart);
 3300              		.loc 1 1445 0
 3301 0054 FB68     		ldr	r3, [r7, #12]
 3302 0056 6822     		movs	r2, #104
 3303 0058 9B5C     		ldrb	r3, [r3, r2]
 3304 005a 012B     		cmp	r3, #1
 3305 005c 01D1     		bne	.L204
 3306              		.loc 1 1445 0 is_stmt 0 discriminator 1
 3307 005e 0223     		movs	r3, #2
 3308 0060 6DE0     		b	.L202
 3309              	.L204:
 3310              		.loc 1 1445 0 discriminator 2
 3311 0062 FB68     		ldr	r3, [r7, #12]
 3312 0064 6822     		movs	r2, #104
 3313 0066 0121     		movs	r1, #1
 3314 0068 9954     		strb	r1, [r3, r2]
1446:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1447:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 3315              		.loc 1 1447 0 is_stmt 1 discriminator 2
 3316 006a FB68     		ldr	r3, [r7, #12]
 3317 006c 0022     		movs	r2, #0
 3318 006e DA66     		str	r2, [r3, #108]
1448:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 3319              		.loc 1 1448 0 discriminator 2
 3320 0070 FB68     		ldr	r3, [r7, #12]
 3321 0072 6922     		movs	r2, #105
 3322 0074 2121     		movs	r1, #33
 3323 0076 9954     		strb	r1, [r3, r2]
1449:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1450:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Init tickstart for timeout managment*/
1451:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     tickstart = HAL_GetTick();
 3324              		.loc 1 1451 0 discriminator 2
 3325 0078 FFF7FEFF 		bl	HAL_GetTick
 3326 007c 0300     		movs	r3, r0
 3327 007e 7B61     		str	r3, [r7, #20]
1452:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1453:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->TxXferSize = Size;
 3328              		.loc 1 1453 0 discriminator 2
 3329 0080 FB68     		ldr	r3, [r7, #12]
 3330 0082 BA1D     		adds	r2, r7, #6
 3331 0084 5021     		movs	r1, #80
 3332 0086 1288     		ldrh	r2, [r2]
 3333 0088 5A52     		strh	r2, [r3, r1]
1454:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->TxXferCount = Size;
 3334              		.loc 1 1454 0 discriminator 2
 3335 008a FB68     		ldr	r3, [r7, #12]
 3336 008c BA1D     		adds	r2, r7, #6
 3337 008e 5221     		movs	r1, #82
 3338 0090 1288     		ldrh	r2, [r2]
 3339 0092 5A52     		strh	r2, [r3, r1]
1455:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     while(huart->TxXferCount > 0)
 3340              		.loc 1 1455 0 discriminator 2
 3341 0094 35E0     		b	.L205
 3342              	.L208:
1456:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1457:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       huart->TxXferCount--;
 3343              		.loc 1 1457 0
 3344 0096 FB68     		ldr	r3, [r7, #12]
 3345 0098 5222     		movs	r2, #82
 3346 009a 9B5A     		ldrh	r3, [r3, r2]
 3347 009c 9BB2     		uxth	r3, r3
 3348 009e 013B     		subs	r3, r3, #1
 3349 00a0 99B2     		uxth	r1, r3
 3350 00a2 FB68     		ldr	r3, [r7, #12]
 3351 00a4 5222     		movs	r2, #82
 3352 00a6 9952     		strh	r1, [r3, r2]
1458:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 3353              		.loc 1 1458 0
 3354 00a8 7A69     		ldr	r2, [r7, #20]
 3355 00aa F868     		ldr	r0, [r7, #12]
 3356 00ac 3B68     		ldr	r3, [r7]
 3357 00ae 0093     		str	r3, [sp]
 3358 00b0 1300     		movs	r3, r2
 3359 00b2 0022     		movs	r2, #0
 3360 00b4 8021     		movs	r1, #128
 3361 00b6 FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 3362 00ba 031E     		subs	r3, r0, #0
 3363 00bc 01D0     		beq	.L206
1459:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1460:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
 3364              		.loc 1 1460 0
 3365 00be 0323     		movs	r3, #3
 3366 00c0 3DE0     		b	.L202
 3367              	.L206:
1461:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1462:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE
 3368              		.loc 1 1462 0
 3369 00c2 FB68     		ldr	r3, [r7, #12]
 3370 00c4 9A68     		ldr	r2, [r3, #8]
 3371 00c6 8023     		movs	r3, #128
 3372 00c8 5B01     		lsls	r3, r3, #5
 3373 00ca 9A42     		cmp	r2, r3
 3374 00cc 11D1     		bne	.L207
 3375              		.loc 1 1462 0 is_stmt 0 discriminator 1
 3376 00ce FB68     		ldr	r3, [r7, #12]
 3377 00d0 1B69     		ldr	r3, [r3, #16]
 3378 00d2 002B     		cmp	r3, #0
 3379 00d4 0DD1     		bne	.L207
1463:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1464:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tmp = (uint16_t*) pData;
 3380              		.loc 1 1464 0 is_stmt 1
 3381 00d6 BB68     		ldr	r3, [r7, #8]
 3382 00d8 3B61     		str	r3, [r7, #16]
1465:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 3383              		.loc 1 1465 0
 3384 00da FB68     		ldr	r3, [r7, #12]
 3385 00dc 1B68     		ldr	r3, [r3]
 3386 00de 3A69     		ldr	r2, [r7, #16]
 3387 00e0 1288     		ldrh	r2, [r2]
 3388 00e2 D205     		lsls	r2, r2, #23
 3389 00e4 D20D     		lsrs	r2, r2, #23
 3390 00e6 92B2     		uxth	r2, r2
 3391 00e8 1A85     		strh	r2, [r3, #40]
1466:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         pData += 2;
 3392              		.loc 1 1466 0
 3393 00ea BB68     		ldr	r3, [r7, #8]
 3394 00ec 0233     		adds	r3, r3, #2
 3395 00ee BB60     		str	r3, [r7, #8]
 3396 00f0 07E0     		b	.L205
 3397              	.L207:
1467:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1468:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
1469:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1470:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
 3398              		.loc 1 1470 0
 3399 00f2 FB68     		ldr	r3, [r7, #12]
 3400 00f4 1A68     		ldr	r2, [r3]
 3401 00f6 BB68     		ldr	r3, [r7, #8]
 3402 00f8 591C     		adds	r1, r3, #1
 3403 00fa B960     		str	r1, [r7, #8]
 3404 00fc 1B78     		ldrb	r3, [r3]
 3405 00fe 9BB2     		uxth	r3, r3
 3406 0100 1385     		strh	r3, [r2, #40]
 3407              	.L205:
1455:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 3408              		.loc 1 1455 0
 3409 0102 FB68     		ldr	r3, [r7, #12]
 3410 0104 5222     		movs	r2, #82
 3411 0106 9B5A     		ldrh	r3, [r3, r2]
 3412 0108 9BB2     		uxth	r3, r3
 3413 010a 002B     		cmp	r3, #0
 3414 010c C3D1     		bne	.L208
1471:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1472:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1473:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 3415              		.loc 1 1473 0
 3416 010e 7A69     		ldr	r2, [r7, #20]
 3417 0110 F868     		ldr	r0, [r7, #12]
 3418 0112 3B68     		ldr	r3, [r7]
 3419 0114 0093     		str	r3, [sp]
 3420 0116 1300     		movs	r3, r2
 3421 0118 0022     		movs	r2, #0
 3422 011a 4021     		movs	r1, #64
 3423 011c FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 3424 0120 031E     		subs	r3, r0, #0
 3425 0122 01D0     		beq	.L209
1474:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1475:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_TIMEOUT;
 3426              		.loc 1 1475 0
 3427 0124 0323     		movs	r3, #3
 3428 0126 0AE0     		b	.L202
 3429              	.L209:
1476:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1477:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1478:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* At end of Tx process, restore huart->gState to Ready */
1479:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->gState = HAL_UART_STATE_READY;
 3430              		.loc 1 1479 0
 3431 0128 FB68     		ldr	r3, [r7, #12]
 3432 012a 6922     		movs	r2, #105
 3433 012c 2021     		movs	r1, #32
 3434 012e 9954     		strb	r1, [r3, r2]
1480:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1481:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Unlocked */
1482:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_UNLOCK(huart);
 3435              		.loc 1 1482 0
 3436 0130 FB68     		ldr	r3, [r7, #12]
 3437 0132 6822     		movs	r2, #104
 3438 0134 0021     		movs	r1, #0
 3439 0136 9954     		strb	r1, [r3, r2]
1483:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1484:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_OK;
 3440              		.loc 1 1484 0
 3441 0138 0023     		movs	r3, #0
 3442 013a 00E0     		b	.L202
 3443              	.L199:
1485:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1486:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1487:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1488:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_BUSY;
 3444              		.loc 1 1488 0
 3445 013c 0223     		movs	r3, #2
 3446              	.L202:
1489:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1490:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 3447              		.loc 1 1490 0
 3448 013e 1800     		movs	r0, r3
 3449 0140 BD46     		mov	sp, r7
 3450 0142 06B0     		add	sp, sp, #24
 3451              		@ sp needed
 3452 0144 80BD     		pop	{r7, pc}
 3453              		.cfi_endproc
 3454              	.LFE49:
 3456 0146 C046     		.bss
 3457              		.align	2
 3458              	tick.6057:
 3459 0000 00000000 		.space	4
 3460              		.text
 3461              	.Letext0:
 3462              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 3463              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 3464              		.file 4 ".././hal/stm32f0/CMSIS/device/stm32f030x6.h"
 3465              		.file 5 ".././hal/stm32f0/CMSIS/device/stm32f0xx.h"
 3466              		.file 6 ".././hal/stm32f0/stm32f0xx_hal_def.h"
 3467              		.file 7 ".././hal/stm32f0/stm32f0xx_hal_rcc.h"
 3468              		.file 8 ".././hal/stm32f0/stm32f0xx_hal_rcc_ex.h"
 3469              		.file 9 ".././hal/stm32f0/stm32f0xx_hal_gpio.h"
 3470              		.file 10 ".././hal/stm32f0/stm32f0xx_hal_dma.h"
 3471              		.file 11 ".././hal/stm32f0/stm32f0xx_hal_uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f0_hal_lowlevel.c
     /tmp/ccSrGzG1.s:20     .text.HAL_GetTick:0000000000000000 $t
     /tmp/ccSrGzG1.s:25     .text.HAL_GetTick:0000000000000000 HAL_GetTick
     /tmp/ccSrGzG1.s:55     .text.HAL_GetTick:0000000000000018 $d
     /tmp/ccSrGzG1.s:3458   .bss:0000000000000000 tick.6057
     /tmp/ccSrGzG1.s:64     .data:0000000000000000 SystemCoreClock
     /tmp/ccSrGzG1.s:61     .data:0000000000000000 $d
     /tmp/ccSrGzG1.s:67     .text.HAL_RCC_GetSysClockFreq:0000000000000000 $t
     /tmp/ccSrGzG1.s:72     .text.HAL_RCC_GetSysClockFreq:0000000000000000 HAL_RCC_GetSysClockFreq
     /tmp/ccSrGzG1.s:98     .text.HAL_RCC_GetPCLK1Freq:0000000000000000 $t
     /tmp/ccSrGzG1.s:103    .text.HAL_RCC_GetPCLK1Freq:0000000000000000 HAL_RCC_GetPCLK1Freq
     /tmp/ccSrGzG1.s:129    .text.HAL_RCC_GetPCLK2Freq:0000000000000000 $t
     /tmp/ccSrGzG1.s:134    .text.HAL_RCC_GetPCLK2Freq:0000000000000000 HAL_RCC_GetPCLK2Freq
     /tmp/ccSrGzG1.s:160    .text.HAL_RCC_OscConfig:0000000000000000 $t
     /tmp/ccSrGzG1.s:165    .text.HAL_RCC_OscConfig:0000000000000000 HAL_RCC_OscConfig
     /tmp/ccSrGzG1.s:687    .text.HAL_RCC_OscConfig:0000000000000324 $d
     /tmp/ccSrGzG1.s:693    .text.HAL_RCC_OscConfig:0000000000000334 $t
     /tmp/ccSrGzG1.s:1108   .text.HAL_RCC_OscConfig:00000000000005d0 $d
     /tmp/ccSrGzG1.s:1117   .text.HAL_RCC_ClockConfig:0000000000000000 $t
     /tmp/ccSrGzG1.s:1122   .text.HAL_RCC_ClockConfig:0000000000000000 HAL_RCC_ClockConfig
     /tmp/ccSrGzG1.s:1398   .text.HAL_RCC_ClockConfig:000000000000019c $d
     /tmp/ccSrGzG1.s:1407   .text.HAL_RCCEx_PeriphCLKConfig:0000000000000000 $t
     /tmp/ccSrGzG1.s:1412   .text.HAL_RCCEx_PeriphCLKConfig:0000000000000000 HAL_RCCEx_PeriphCLKConfig
     /tmp/ccSrGzG1.s:1671   .text.HAL_RCCEx_PeriphCLKConfig:0000000000000184 $d
     /tmp/ccSrGzG1.s:1681   .text.HAL_GPIO_Init:0000000000000000 $t
     /tmp/ccSrGzG1.s:1686   .text.HAL_GPIO_Init:0000000000000000 HAL_GPIO_Init
     /tmp/ccSrGzG1.s:2155   .text.HAL_GPIO_Init:00000000000002d0 $d
     /tmp/ccSrGzG1.s:2165   .text.HAL_GPIO_WritePin:0000000000000000 $t
     /tmp/ccSrGzG1.s:2170   .text.HAL_GPIO_WritePin:0000000000000000 HAL_GPIO_WritePin
     /tmp/ccSrGzG1.s:2225   .text.UART_WaitOnFlagUntilTimeout:0000000000000000 $t
     /tmp/ccSrGzG1.s:2230   .text.UART_WaitOnFlagUntilTimeout:0000000000000000 UART_WaitOnFlagUntilTimeout
     /tmp/ccSrGzG1.s:2337   .text.UART_WaitOnFlagUntilTimeout:0000000000000094 $d
     /tmp/ccSrGzG1.s:2342   .text.UART_CheckIdleState:0000000000000000 $t
     /tmp/ccSrGzG1.s:2347   .text.UART_CheckIdleState:0000000000000000 UART_CheckIdleState
     /tmp/ccSrGzG1.s:2397   .text.UART_SetConfig:0000000000000000 $t
     /tmp/ccSrGzG1.s:2402   .text.UART_SetConfig:0000000000000000 UART_SetConfig
     /tmp/ccSrGzG1.s:2814   .text.UART_SetConfig:00000000000002a4 $d
     /tmp/ccSrGzG1.s:2824   .text.HAL_UART_Init:0000000000000000 $t
     /tmp/ccSrGzG1.s:2829   .text.HAL_UART_Init:0000000000000000 HAL_UART_Init
     /tmp/ccSrGzG1.s:2935   .text.HAL_UART_Init:0000000000000094 $d
     /tmp/ccSrGzG1.s:2940   .text.HAL_UART_Receive:0000000000000000 $t
     /tmp/ccSrGzG1.s:2945   .text.HAL_UART_Receive:0000000000000000 HAL_UART_Receive
     /tmp/ccSrGzG1.s:3221   .text.HAL_UART_Receive:0000000000000198 $d
     /tmp/ccSrGzG1.s:3226   .text.HAL_UART_Transmit:0000000000000000 $t
     /tmp/ccSrGzG1.s:3231   .text.HAL_UART_Transmit:0000000000000000 HAL_UART_Transmit
     /tmp/ccSrGzG1.s:3457   .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
__aeabi_uidiv
